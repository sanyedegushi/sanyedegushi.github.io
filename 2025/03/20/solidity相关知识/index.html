<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Solidity 学习笔记 | 三叶的故事</title><meta name="author" content="三叶"><meta name="copyright" content="三叶"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="其中solidity是一门专门用于编写智能合约的高级语言，在以太坊虚拟机上运行。它是一种静态类型语言，受 JavaScript、Python 和 C++ 的影响，具有合约、状态变量、函数修饰符和事件等概念，适用于去中心化应用（DApp）和区块链开发。 智能合约的概念智能合约（Smart Contract）是一种运行在区块链上的自执行合约，其条款以代码形式直接写入区块链。一旦满足设定的条件，合约便会">
<meta property="og:type" content="article">
<meta property="og:title" content="Solidity 学习笔记">
<meta property="og:url" content="http://example.com/2025/03/20/solidity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="三叶的故事">
<meta property="og:description" content="其中solidity是一门专门用于编写智能合约的高级语言，在以太坊虚拟机上运行。它是一种静态类型语言，受 JavaScript、Python 和 C++ 的影响，具有合约、状态变量、函数修饰符和事件等概念，适用于去中心化应用（DApp）和区块链开发。 智能合约的概念智能合约（Smart Contract）是一种运行在区块链上的自执行合约，其条款以代码形式直接写入区块链。一旦满足设定的条件，合约便会">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/san-ye.png">
<meta property="article:published_time" content="2025-03-19T23:00:00.000Z">
<meta property="article:modified_time" content="2025-03-21T11:11:58.157Z">
<meta property="article:author" content="三叶">
<meta property="article:tag" content="Solidity">
<meta property="article:tag" content="区块链">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/san-ye.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Solidity 学习笔记",
  "url": "http://example.com/2025/03/20/solidity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/",
  "image": "http://example.com/img/san-ye.png",
  "datePublished": "2025-03-19T23:00:00.000Z",
  "dateModified": "2025-03-21T11:11:58.157Z",
  "author": [
    {
      "@type": "Person",
      "name": "三叶",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/bi-qi-gu.png"><link rel="canonical" href="http://example.com/2025/03/20/solidity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Solidity 学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/san-ye.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">三叶的故事</span></a><a class="nav-page-title" href="/"><span class="site-name">Solidity 学习笔记</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Solidity 学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-19T23:00:00.000Z" title="发表于 2025-03-20 07:00:00">2025-03-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-21T11:11:58.157Z" title="更新于 2025-03-21 19:11:58">2025-03-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91/">开发</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91/Solidity/">Solidity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>其中solidity是一门专门用于编写智能合约的高级语言，在以太坊虚拟机上运行。它是一种静态类型语言，受 JavaScript、Python 和 C++ 的影响，具有合约、状态变量、函数修饰符和事件等概念，适用于去中心化应用（DApp）和区块链开发。</p>
<h2 id="智能合约的概念"><a href="#智能合约的概念" class="headerlink" title="智能合约的概念"></a>智能合约的概念</h2><p>智能合约（Smart Contract）是一种运行在区块链上的自执行合约，其条款以代码形式直接写入区块链。一旦满足设定的条件，合约便会自动执行，且不可篡改。智能合约通常用于去中心化金融（DeFi）、NFT、供应链管理等场景，以实现信任最小化和自动化交易。</p>
<h1 id="1-变量类型"><a href="#1-变量类型" class="headerlink" title="1.变量类型"></a>1.变量类型</h1><p>常用三种类型：</p>
<p><strong>1.值类型：</strong> 布尔型（bool),整数型（int)，正整数（uint）等</p>
<p>2.<strong>引用类型：</strong> 数组（arry[]),结构体（struct）等</p>
<p>3.<strong>映射类型</strong>：存储键值对的数据结构（mapping）</p>
<h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><h3 id="1布尔型"><a href="#1布尔型" class="headerlink" title="1布尔型"></a>1布尔型</h3><p>布尔型是二值变量，取值为 <code>true</code> 或 <code>false</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool san = ture;</span><br></pre></td></tr></table></figure>

<p>布尔值的运算符包括：</p>
<ul>
<li><code>!</code> （逻辑非）</li>
<li><code>&amp;&amp;</code> （逻辑与，”and”）</li>
<li><code>||</code> （逻辑或，”or”）</li>
<li><code>==</code> （等于）</li>
<li><code>!=</code> （不等于）</li>
</ul>
<h3 id="2-整型"><a href="#2-整型" class="headerlink" title="2 整型"></a>2 整型</h3><p>solidity中的整数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int public _int = -1; // 整数，包括负数</span><br><span class="line">uint public _uint = 1; // 正整数</span><br><span class="line">uint256 public _number = 20220330; // 256位正整数</span><br></pre></td></tr></table></figure>

<p>常用的整型运算符包括：</p>
<ul>
<li>比较运算符（返回布尔值）： <code>&lt;=</code>， <code>&lt;</code>，<code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code></li>
<li>算数运算符： <code>+</code>， <code>-</code>， <code>*</code>， <code>/</code>， <code>%</code>（取余），<code>**</code>（幂）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//整数运算</span><br><span class="line">uint256 public _number1 = _number + 1; // +，-，*，/</span><br><span class="line">uint256 public _number2 = 2**2; // 指数</span><br><span class="line">uint256 public _number3 = 7 % 2; // 取余数</span><br><span class="line">bool public _numberbool = _number2 &gt; _number3; // 比大小</span><br></pre></td></tr></table></figure>

<h3 id="3-地址类型"><a href="#3-地址类型" class="headerlink" title="3.地址类型"></a>3.地址类型</h3><p>其中分为两种类型：</p>
<ul>
<li><p><strong>普通地址（address）</strong>： 存储一个 20 字节的值（以太坊地址的大小）。</p>
</li>
<li><p><strong>payable address</strong> : 比普通地址多了 <code>transfer</code> 和 <code>send</code> 两个成员方法，用于接收转账。</p>
</li>
</ul>
<h3 id="4-字长字节数组"><a href="#4-字长字节数组" class="headerlink" title="4.字长字节数组"></a>4.字长字节数组</h3><p>字节数组分为定长和不定长两种：</p>
<ul>
<li>定长字节数组: 属于值类型，数组长度在声明之后不能改变。根据字节数组的长度分为 <code>bytes1</code>, <code>bytes8</code>, <code>bytes32</code> 等类型。定长字节数组最多存储 32 bytes 数据，即<code>bytes32</code>。</li>
<li>不定长字节数组: 属于引用类型数组长度在声明之后可以改变，包括 <code>bytes</code> 等（动态数组）</li>
</ul>
<h1 id="2-函数"><a href="#2-函数" class="headerlink" title="2.函数"></a>2.函数</h1><h2 id="四种函数"><a href="#四种函数" class="headerlink" title="四种函数"></a>四种函数</h2><ul>
<li><p>公共函数</p>
</li>
<li><p>内部函数</p>
</li>
<li><p>外部函数</p>
</li>
<li><p>私有函数</p>
</li>
</ul>
<h3 id="详细介绍-1"><a href="#详细介绍-1" class="headerlink" title="详细介绍"></a>详细介绍</h3><h4 id="1-公共函数"><a href="#1-公共函数" class="headerlink" title="1.公共函数"></a>1.公共函数</h4><p><strong>特点</strong>： 可以从合约外部和内部调用，默认可见修饰符。</p>
<p><strong>调用方式：</strong> 可以直接在合约内调用。可以从合约外部通过合约地址调用。</p>
<p><strong>限制</strong>： 无限制</p>
<p><strong>继承</strong>：可以被继承并在子合约中重写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">contract Example &#123;    </span><br><span class="line">function publicFunction() public pure returns (string memory) &#123;        </span><br><span class="line">			return &quot;This is a public function&quot;;    &#125;     </span><br><span class="line">function callPublicFunction() public pure returns (string memory) &#123;        </span><br><span class="line">			return publicFunction(); // 内部调用    &#125; </span><br><span class="line">		&#125; // 外部调用 Example example = new Example(); example.publicFunction();</span><br></pre></td></tr></table></figure>



<h4 id="2-内部函数"><a href="#2-内部函数" class="headerlink" title="2.内部函数"></a>2.内部函数</h4><p><strong>特点</strong>：只能在当前合约和从当前合约继承的合约中调用，比public函数更加高效，因为他们不会涉及外部调用的开销。</p>
<p>**调用方式：**只能在合约内或继承合约中调用</p>
<p>**限制：**不能从合约外部调用</p>
<p>**继承：**可以被继承并且子合约中调用或被重写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract Parent &#123;    </span><br><span class="line">	function internalFunction() internal pure returns (string memory) &#123;        </span><br><span class="line">		return &quot;This is an internal function&quot;;    &#125;     </span><br><span class="line">	function callInternalFunction() public pure returns (string memory) &#123;        </span><br><span class="line">		return internalFunction(); // 内部调用    &#125; </span><br><span class="line">&#125; </span><br><span class="line">contract Child is Parent &#123;    </span><br><span class="line">	function callParentInternalFunction() public pure returns (string memory) &#123;        </span><br><span class="line">		return internalFunction(); // 继承合约中调用    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-外部函数"><a href="#3-外部函数" class="headerlink" title="3.外部函数"></a>3.外部函数</h4><p>**特点：**只能从合约外部调用。可以通过this关键子从合约外部调用，但是效率低。</p>
<p>**调用方式：**从合约外部通过合约地址调用，使用this关键字调用</p>
<p>**限制：**不能直接在合约内部调用</p>
<p>**继承：**可以被继承，并在子合约中重写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">contract Example &#123;    </span><br><span class="line">	function externalFunction() external pure returns (string memory) &#123;        </span><br><span class="line">			return &quot;This is an external function&quot;;    &#125;     </span><br><span class="line">	function callExternalFunction() public view returns (string memory) &#123;        </span><br><span class="line">			return this.externalFunction(); // 使用 `this` 关键字调用    &#125; </span><br><span class="line">&#125; // 外部调用 Example example = new Example(); example.externalFunction();</span><br></pre></td></tr></table></figure>

<h4 id="4-私有函数"><a href="#4-私有函数" class="headerlink" title="4.私有函数"></a>4.私有函数</h4><p>**特点：**只能在当前合约内部调用，访问权限最严格。</p>
<p>**调用方式：**只能在合约内部调用</p>
<p>**限制：**不能从合约外部或继承合约中调用。</p>
<p>**继承：**不能被继承，子合约无法访问或者重写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">contract Example &#123;    </span><br><span class="line">function privateFunction() private pure returns (string memory) &#123;        </span><br><span class="line">		return &quot;This is a private function&quot;;    &#125;     </span><br><span class="line">function callPrivateFunction() public pure returns (string memory) &#123;        </span><br><span class="line">		return privateFunction(); // 内部调用    &#125;</span><br><span class="line">&#125; // 无法从外部或继承合约中调用</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong><code>public</code></strong>: 可在任何地方调用，包括合约内部和外部，并可继承。</p>
<p><strong><code>internal</code></strong>: 只能在当前合约和继承合约中调用，并可继承。</p>
<p><strong><code>external</code></strong>: 只能从合约外部调用，可通过 <code>this</code> 关键字在内部调用，并可继承。</p>
<p><strong><code>private</code></strong>: 只能在当前合约内部调用，不能继承。</p>
<h1 id="3-控制流"><a href="#3-控制流" class="headerlink" title="3.控制流"></a>3.控制流</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><h3 id="1语法："><a href="#1语法：" class="headerlink" title="1语法："></a>1语法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (条件) &#123;</span><br><span class="line">    // 当条件为 true 时执行的代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-if-else-语句"><a href="#2-if-else-语句" class="headerlink" title="2.if-else 语句"></a>2.<code>if-else</code> 语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (条件) &#123;</span><br><span class="line">    // 条件为 true 时执行</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 条件为 false 时执行</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-if-else-if-else-语句"><a href="#3-if-else-if-else-语句" class="headerlink" title="3. if-else if-else 语句"></a>3. <code>if-else if-else</code> 语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (条件1) &#123;</span><br><span class="line">    // 条件1 为 true 时执行</span><br><span class="line">&#125; else if (条件2) &#123;</span><br><span class="line">    // 条件2 为 true 时执行</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 所有条件都不满足时执行</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="for循环-以及其他循环"><a href="#for循环-以及其他循环" class="headerlink" title="for循环(以及其他循环)"></a>for循环(以及其他循环)</h2><h2 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (初始化; 条件; 迭代) &#123;</span><br><span class="line">    // 代码块</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2.while循环"></a>2.while循环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract WhileLoopExample &#123;</span><br><span class="line">    function sum(uint256 n) public pure returns (uint256) &#123;</span><br><span class="line">        uint256 total = 0;</span><br><span class="line">        uint256 i = 1;</span><br><span class="line">        while (i &lt;= n) &#123;</span><br><span class="line">            total += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-do-while-循环"><a href="#3-do-while-循环" class="headerlink" title="3.do-while 循环"></a>3.do-while 循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract DoWhileExample &#123;</span><br><span class="line">    function decrement(uint256 n) public pure returns (uint256) &#123;</span><br><span class="line">        uint256 counter = n;</span><br><span class="line">        do &#123;</span><br><span class="line">            counter--;</span><br><span class="line">        &#125; while (counter &gt; 0);</span><br><span class="line">        return counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><code>do-while</code> <strong>至少会执行一次</strong>，即使初始条件不满足。</li>
</ul>
<h1 id="4继承"><a href="#4继承" class="headerlink" title="4继承"></a>4继承</h1><p><strong>继承规则</strong>：</p>
<ul>
<li><code>virtual</code>: 父合约中的函数，如果希望子合约重写，需要加上<code>virtual</code>关键字。</li>
<li><code>override</code>：子合约重写了父合约中的函数，需要加上<code>override</code>关键字。</li>
</ul>
<p><strong>注意</strong>：用<code>override</code>修饰<code>public</code>变量，会重写与变量同名的<code>getter</code>函数，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(address =&gt; uint256) public override balanceOf;</span><br></pre></td></tr></table></figure>

<h2 id="简单继承"><a href="#简单继承" class="headerlink" title="简单继承"></a>简单继承</h2><p>我们先写一个简单的爷爷合约<code>Yeye</code>，里面包含1个<code>Log</code>事件和3个<code>function</code>: <code>hip()</code>, <code>pop()</code>, <code>yeye()</code>，输出都是”Yeye”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract Yeye &#123;</span><br><span class="line">    event Log(string msg);</span><br><span class="line"></span><br><span class="line">    // 定义3个function: hip(), pop(), man()，Log值为Yeye。</span><br><span class="line">    function hip() public virtual&#123;</span><br><span class="line">        emit Log(&quot;Yeye&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pop() public virtual&#123;</span><br><span class="line">        emit Log(&quot;Yeye&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function yeye() public virtual &#123;</span><br><span class="line">        emit Log(&quot;Yeye&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再定义一个爸爸合约<code>Baba</code>，让他继承<code>Yeye</code>合约，语法就是<code>contract Baba is Yeye</code>，非常直观。在<code>Baba</code>合约里，我们重写一下<code>hip()</code>和<code>pop()</code>这两个函数，加上<code>override</code>关键字，并将他们的输出改为<code>”Baba”</code>；并且加一个新的函数<code>baba</code>，输出也是<code>”Baba”</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract Baba is Yeye&#123;</span><br><span class="line">    // 继承两个function: hip()和pop()，输出改为Baba。</span><br><span class="line">    function hip() public virtual override&#123;</span><br><span class="line">        emit Log(&quot;Baba&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pop() public virtual override&#123;</span><br><span class="line">        emit Log(&quot;Baba&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function baba() public virtual&#123;</span><br><span class="line">        emit Log(&quot;Baba&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们部署合约，可以看到<code>Baba</code>合约里有4个函数，其中<code>hip()</code>和<code>pop()</code>的输出被成功改写成<code>”Baba”</code>，而继承来的<code>yeye()</code>的输出仍然是<code>”Yeye”</code>。</p>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p><code>Solidity</code>的合约可以继承多个合约。</p>
<p>规则：</p>
<ol>
<li>继承时要按辈分最高到最低的顺序排。比如我们写一个<code>Erzi</code>合约，继承<code>Yeye</code>合约和<code>Baba</code>合约，那么就要写成<code>contract Erzi is Yeye, Baba</code>，而不能写成<code>contract Erzi is Baba, Yeye</code>，不然就会报错。（即按照合约的复杂程度大小排序）</li>
<li>如果某一个函数在多个继承的合约里都存在，比如例子中的<code>hip()</code>和<code>pop()</code>，在子合约里必须重写，不然会报错。</li>
<li>重写在多个父合约中都重名的函数时，<code>override</code>关键字后面要加上所有父合约名字，例如<code>override(Yeye, Baba)</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract Erzi is Yeye, Baba&#123;</span><br><span class="line">    // 继承两个function: hip()和pop()，输出值为Erzi。</span><br><span class="line">    function hip() public virtual override(Yeye, Baba)&#123;</span><br><span class="line">        emit Log(&quot;Erzi&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pop() public virtual override(Yeye, Baba) &#123;</span><br><span class="line">        emit Log(&quot;Erzi&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，<code>Erzi</code>合约里面重写了<code>hip()</code>和<code>pop()</code>两个函数，将输出改为<code>”Erzi”</code>，并且还分别从<code>Yeye</code>和<code>Baba</code>合约继承了<code>yeye()</code>和<code>baba()</code>两个函数。</p>
<h2 id="修饰器的继承"><a href="#修饰器的继承" class="headerlink" title="修饰器的继承"></a>修饰器的继承</h2><p><code>Solidity</code>中的修饰器（<code>Modifier</code>）同样可以继承，用法与函数继承类似，在相应的地方加<code>virtual</code>和<code>override</code>关键字即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">contract Base1 &#123;</span><br><span class="line">    modifier exactDividedBy2And3(uint _a) virtual &#123;</span><br><span class="line">        require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Identifier is Base1 &#123;</span><br><span class="line"></span><br><span class="line">    //计算一个数分别被2除和被3除的值，但是传入的参数必须是2和3的倍数</span><br><span class="line">    function getExactDividedBy2And3(uint _dividend) public exactDividedBy2And3(_dividend) pure returns(uint, uint) &#123;</span><br><span class="line">        return getExactDividedBy2And3WithoutModifier(_dividend);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算一个数分别被2除和被3除的值</span><br><span class="line">    function getExactDividedBy2And3WithoutModifier(uint _dividend) public pure returns(uint, uint)&#123;</span><br><span class="line">        uint div2 = _dividend / 2;</span><br><span class="line">        uint div3 = _dividend / 3;</span><br><span class="line">        return (div2, div3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Identifier</code>合约可以直接在代码中使用父合约中的<code>exactDividedBy2And3</code>修饰器，也可以利用<code>override</code>关键字重写修饰器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modifier exactDividedBy2And3(uint _a) override &#123;</span><br><span class="line">    _;</span><br><span class="line">    require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h2><p>子合约有两种方法继承父合约的构造函数。举个简单的例子，父合约<code>A</code>里面有一个状态变量<code>a</code>，并由构造函数的参数来确定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数的继承</span><br><span class="line">abstract contract A &#123;</span><br><span class="line">    uint public a;</span><br><span class="line"></span><br><span class="line">    constructor(uint _a) &#123;</span><br><span class="line">        a = _a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>在继承时声明父构造函数的参数，例如：<code>contract B is A(1)</code></p>
</li>
<li><p>在子合约的构造函数中声明构造函数的参数，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract C is A &#123;</span><br><span class="line">    constructor(uint _c) A(_c * _c) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="调用父合约的函数"><a href="#调用父合约的函数" class="headerlink" title="调用父合约的函数"></a>调用父合约的函数</h2><p>子合约有两种方式调用父合约的函数，直接调用和利用<code>super</code>关键字。</p>
<ol>
<li><p>直接调用：子合约可以直接用<code>父合约名.函数名()</code>的方式来调用父合约函数，例如<code>Yeye.pop()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function callParent() public&#123;</span><br><span class="line">    Yeye.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>super</code>关键字：子合约可以利用<code>super.函数名()</code>来调用最近的父合约函数。<code>Solidity</code>继承关系按声明时从右到左的顺序是：<code>contract Erzi is Yeye, Baba</code>，那么<code>Baba</code>是最近的父合约，<code>super.pop()</code>将调用<code>Baba.pop()</code>而不是<code>Yeye.pop()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function callParentSuper() public&#123;</span><br><span class="line">    // 将调用最近的父合约函数，Baba.pop()</span><br><span class="line">    super.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="钻石继承"><a href="#钻石继承" class="headerlink" title="钻石继承"></a>钻石继承</h2><p>在面向对象编程中，钻石继承（菱形继承）指一个派生类同时有两个或两个以上的基类。</p>
<p>在多重+菱形继承链条上使用<code>super</code>关键字时，需要注意的是使用<code>super</code>会调用继承链条上的每一个合约的相关函数，而不是只调用最近的父合约。</p>
<p>我们先写一个合约<code>God</code>，再写<code>Adam</code>和<code>Eve</code>两个合约继承<code>God</code>合约，最后让创建合约<code>people</code>继承自<code>Adam</code>和<code>Eve</code>，每个合约都有<code>foo</code>和<code>bar</code>两个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">/* 继承树：</span><br><span class="line">  God</span><br><span class="line"> /  \</span><br><span class="line">Adam Eve</span><br><span class="line"> \  /</span><br><span class="line"> </span><br><span class="line">people</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">contract God &#123;</span><br><span class="line">    event Log(string message);</span><br><span class="line"></span><br><span class="line">    function foo() public virtual &#123;</span><br><span class="line">        emit Log(&quot;God.foo called&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bar() public virtual &#123;</span><br><span class="line">        emit Log(&quot;God.bar called&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Adam is God &#123;</span><br><span class="line">    function foo() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;Adam.foo called&quot;);</span><br><span class="line">        super.foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bar() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;Adam.bar called&quot;);</span><br><span class="line">        super.bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Eve is God &#123;</span><br><span class="line">    function foo() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;Eve.foo called&quot;);</span><br><span class="line">        super.foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bar() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;Eve.bar called&quot;);</span><br><span class="line">        super.bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract people is Adam, Eve &#123;</span><br><span class="line">    function foo() public override(Adam, Eve) &#123;</span><br><span class="line">        super.foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bar() public override(Adam, Eve) &#123;</span><br><span class="line">        super.bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，调用合约<code>people</code>中的<code>super.bar()</code>会依次调用<code>Eve</code>、<code>Adam</code>，最后是<code>God</code>合约。</p>
<h1 id="5-抽象合约"><a href="#5-抽象合约" class="headerlink" title="5.抽象合约"></a>5.抽象合约</h1><h2 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a>抽象合约</h2><p>如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体<code>&#123;&#125;</code>中的内容，则必须将该合约标为<code>abstract</code>，不然编译会报错；另外，未实现的函数需要加<code>virtual</code>，以便子合约重写。拿我们之前的<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/tree/main/10_InsertionSort">插入排序合约</a>为例，如果我们还没想好具体怎么实现插入排序函数，那么可以把合约标为<code>abstract</code>，之后让别人补写上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract contract InsertionSort&#123;</span><br><span class="line">    function insertionSort(uint[] memory a) public pure virtual returns(uint[] memory);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-接口"><a href="#6-接口" class="headerlink" title="6.接口"></a>6.接口</h1><ol>
<li>不能包含状态变量</li>
<li>不能包含构造函数</li>
<li>不能继承除接口外的其他合约</li>
<li>所有函数都必须是external且不能有函数体</li>
<li>继承接口的非抽象合约必须实现接口定义的所有功能</li>
</ol>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>接口是智能合约的骨架，定义合约的功能以如何触发他们，</p>
<p>如果智能合约实现了某种接口（比如<code>ERC20</code>或<code>ERC721</code>），其他Dapps和智能合约就知道如何与它交互。因为接口提供了两个重要的信息：</p>
<ol>
<li>合约里每个函数的<code>bytes4</code>选择器，以及函数签名<code>函数名(每个参数类型）</code>。</li>
<li>接口id</li>
</ol>
<p>另外，接口与合约<code>ABI</code>（Application Binary Interface）等价，可以相互转换：编译接口可以得到合约的<code>ABI</code>，利用<a target="_blank" rel="noopener" href="https://gnidan.github.io/abi-to-sol/">abi-to-sol工具</a>，也可以将<code>ABI json</code>文件转换为<code>接口sol</code>文件。</p>
<p>我们以<code>ERC721</code>接口合约<code>IERC721</code>为例，它定义了3个<code>event</code>和9个<code>function</code>，所有<code>ERC721</code>标准的NFT都实现了这些函数。我们可以看到，接口和常规合约的区别在于每个函数都以<code>;</code>代替函数体<code>&#123; &#125;</code>结尾。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">interface IERC721 is IERC165 &#123;</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);</span><br><span class="line">    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);</span><br><span class="line">    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);</span><br><span class="line">    </span><br><span class="line">    function balanceOf(address owner) external view returns (uint256 balance);</span><br><span class="line"></span><br><span class="line">    function ownerOf(uint256 tokenId) external view returns (address owner);</span><br><span class="line"></span><br><span class="line">    function safeTransferFrom(address from, address to, uint256 tokenId) external;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint256 tokenId) external;</span><br><span class="line"></span><br><span class="line">    function approve(address to, uint256 tokenId) external;</span><br><span class="line"></span><br><span class="line">    function getApproved(uint256 tokenId) external view returns (address operator);</span><br><span class="line"></span><br><span class="line">    function setApprovalForAll(address operator, bool _approved) external;</span><br><span class="line"></span><br><span class="line">    function isApprovedForAll(address owner, address operator) external view returns (bool);</span><br><span class="line"></span><br><span class="line">    function safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data) external;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么时候使用接口？"><a href="#什么时候使用接口？" class="headerlink" title="什么时候使用接口？"></a>什么时候使用接口？</h2><p>如果我们知道一个合约实现了<code>IERC721</code>接口，我们不需要知道它具体代码实现，就可以与它交互。</p>
<p>无聊猿<code>BAYC</code>属于<code>ERC721</code>代币，实现了<code>IERC721</code>接口的功能。我们不需要知道它的源代码，只需知道它的合约地址，用<code>IERC721</code>接口就可以与它交互，比如用<code>balanceOf()</code>来查询某个地址的<code>BAYC</code>余额，用<code>safeTransferFrom()</code>来转账<code>BAYC</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract interactBAYC &#123;</span><br><span class="line">    // 利用BAYC地址创建接口合约变量（ETH主网）</span><br><span class="line">    IERC721 BAYC = IERC721(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D);</span><br><span class="line"></span><br><span class="line">    // 通过接口调用BAYC的balanceOf()查询持仓量</span><br><span class="line">    function balanceOfBAYC(address owner) external view returns (uint256 balance)&#123;</span><br><span class="line">        return BAYC.balanceOf(owner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 通过接口调用BAYC的safeTransferFrom()安全转账</span><br><span class="line">    function safeTransferFromBAYC(address from, address to, uint256 tokenId) external&#123;</span><br><span class="line">        BAYC.safeTransferFrom(from, to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象合约的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个抽象合约 Animal</span><br><span class="line">abstract contract Animal &#123;</span><br><span class="line">    // 声明一个未实现的函数</span><br><span class="line">    function makeSound() public virtual returns (string memory);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 可以有其他实现的函数</span><br><span class="line">    function move() public virtual returns (string memory) &#123;</span><br><span class="line">        return &quot;Moving...&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体实现的合约 Dog</span><br><span class="line">contract Dog is Animal &#123;</span><br><span class="line">    function makeSound() public override returns (string memory) &#123;</span><br><span class="line">        return &quot;Woof!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体实现的合约 Cat</span><br><span class="line">contract Cat is Animal &#123;</span><br><span class="line">    function makeSound() public override returns (string memory) &#123;</span><br><span class="line">        return &quot;Meow!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>Animal</code> 是一个抽象合约，使用 <code>abstract</code> 关键字声明。</p>
<p><code>Animal</code> 中声明了一个未实现的函数 <code>makeSound()</code>，以及一个有默认实现的函数 <code>move()</code>。</p>
<p><code>Dog</code> 和 <code>Cat</code> 合约分别继承了 <code>Animal</code> 抽象合约，并实现了 <code>makeSound()</code> 函数，分别返回了狗和猫的叫声。</p>
<p>接口的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个接口 Animal</span><br><span class="line">interface Animal &#123;</span><br><span class="line">    function makeSound() external returns (string memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体实现的合约 Dog</span><br><span class="line">contract Dog is Animal &#123;</span><br><span class="line">    function makeSound() public override returns (string memory) &#123;</span><br><span class="line">        return &quot;Woof!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体实现的合约 Cat</span><br><span class="line">contract Cat is Animal &#123;</span><br><span class="line">    function makeSound() public override returns (string memory) &#123;</span><br><span class="line">        return &quot;Meow!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这个示例中，<code>Animal</code> 是一个接口，声明了一个函数 <code>makeSound()</code>，没有提供具体的实现。<code>Dog</code> 和 <code>Cat</code> 合约分别实现了 <code>Animal</code> 接口，并提供了 <code>makeSound()</code> 函数的具体实现，分别返回狗和猫的叫声。</p>
<h3 id="区别和使用场景："><a href="#区别和使用场景：" class="headerlink" title="区别和使用场景："></a>区别和使用场景：</h3><ul>
<li><strong>抽象合约</strong>通常用于定义具有部分实现的合约，可以包含实现的函数和未实现的函数。</li>
<li><strong>接口</strong>是完全未实现的合约，用于定义函数的签名和行为，强制要求实现合约必须提供具体的实现。</li>
</ul>
<h1 id="7-事件"><a href="#7-事件" class="headerlink" title="7 事件"></a>7 事件</h1><p>当触发事件的时候有俩种参数类型：</p>
<ul>
<li>indexed参数</li>
<li>非indexed参数</li>
</ul>
<p>最多可以有三个indexed参数 ，也被称为topics（主题）；indexed只能用于 uint，address类型的变量；</p>
<h3 id="主题-topics"><a href="#主题-topics" class="headerlink" title="主题 topics"></a>主题 <code>topics</code></h3><p>日志的第一部分是主题数组，用于描述事件，长度不能超过<code>4</code>。它的第一个元素是事件的签名（哈希）。对于上面的<code>Transfer</code>事件，它的事件哈希就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keccak256(&quot;Transfer(address,address,uint256)&quot;)</span><br><span class="line"></span><br><span class="line">//0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef</span><br></pre></td></tr></table></figure>

<p>除了事件哈希，主题还可以包含至多<code>3</code>个<code>indexed</code>参数，也就是<code>Transfer</code>事件中的<code>from</code>和<code>to</code>。</p>
<p><code>indexed</code>标记的参数可以理解为检索事件的索引“键”，方便之后搜索。每个 <code>indexed</code> 参数的大小为固定的256比特，如果参数太大了（比如字符串），就会自动计算哈希存储在主题中。</p>
<h3 id="数据-data"><a href="#数据-data" class="headerlink" title="数据 data"></a>数据 <code>data</code></h3><p>事件中不带 <code>indexed</code>的参数会被存储在 <code>data</code> 部分中，可以理解为事件的“值”。<code>data</code> 部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般 <code>data</code> 部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的 <code>topics</code> 部分中，也是以哈希的方式存储。另外，<code>data</code> 部分的变量在存储上消耗的gas相比于 <code>topics</code> 更少。</p>
<p>**简介：**solidity 中事件是EVM上日志的抽象:</p>
<p>**响应：**应用程序（<a target="_blank" rel="noopener" href="https://learnblockchain.cn/docs/ethers.js/api-contract.html#id18"><code>ethers.js</code></a>）可以通过<code>RPC</code>接口订阅和监听这些事件，并在前端做响应。</p>
<p>**经济：**事件相对于一个新变量更加经济，（一个事件大概2000gas，新变量一个要20000gas）</p>
<p>**声明时间：**由event开头，后面是时间的名称，在括号里面是（变量类型和变量名）</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event Transfer(address indexed from, address indexed to, uint256 value);</span><br></pre></td></tr></table></figure>

<h3 id="释放事件"><a href="#释放事件" class="headerlink" title="释放事件"></a>释放事件</h3><p>我们可以在函数里释放事件。在下面的例子中，每次用<code>_transfer()</code>函数进行转账操作的时候，都会释放<code>Transfer</code>事件，并记录相应的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 定义_transfer函数，执行转账逻辑</span><br><span class="line">function _transfer(</span><br><span class="line">    address from,</span><br><span class="line">    address to,</span><br><span class="line">    uint256 amount</span><br><span class="line">) external &#123;</span><br><span class="line"></span><br><span class="line">    _balances[from] = 10000000; // 给转账地址一些初始代币</span><br><span class="line"></span><br><span class="line">    _balances[from] -=  amount; // from地址减去转账数量</span><br><span class="line">    _balances[to] += amount; // to地址加上转账数量</span><br><span class="line"></span><br><span class="line">    // 释放事件</span><br><span class="line">    emit Transfer(from, to, amount);//可以受用eimt来释放事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-日志"><a href="#8-日志" class="headerlink" title="8.日志"></a>8.日志</h1><p>日志（Event）是 Solidity 语言提供的一个重要功能，用于在 EVM 内部记录区块链上的事件。Event 主要用于在链下监听智能合约的状态变化，减少对区块链状态的频繁查询，提高效率。日志由 EVM 处理，并存储在交易的 <code>logs</code> 部分，智能合约本身无法直接访问。</p>
<h2 id="1特点"><a href="#1特点" class="headerlink" title="1特点"></a>1特点</h2><p><strong>存储在交易日志中，不占用合约存储空间</strong>：事件数据不会占用 <code>storage</code>，因此 gas 费用更低。</p>
<p><strong>无法在智能合约内部读取</strong>：Event 仅用于链外监听（off-chain），不能在智能合约内直接调用。</p>
<p><strong>可以携带索引（indexed）</strong>：允许最多 <strong>三个 indexed 参数</strong>，方便链外工具（如 Web3.js、ethers.js）高效检索。</p>
<p><strong>用于链上事件通知</strong>：DApp 开发中，前端可以监听事件，以响应合约执行状态的变化。</p>
<h2 id="2-日志的声明与使用"><a href="#2-日志的声明与使用" class="headerlink" title="2.日志的声明与使用"></a>2.日志的声明与使用</h2><p>在 Solidity 中，日志通过 <code>event</code> 关键字定义，并使用 <code>emit</code> 关键字触发。</p>
<h4 id="2-1-定义日志"><a href="#2-1-定义日志" class="headerlink" title="2.1 定义日志"></a>2.1 <strong>定义日志</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">solidity复制编辑// 定义一个事件，记录转账信息</span><br><span class="line">event Transfer(address indexed from, address indexed to, uint256 value);</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><pre><code>Transfer
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   事件包含 3 个参数：</span><br><span class="line"></span><br><span class="line">  - `from`（`indexed`）：发送方地址</span><br><span class="line">  - `to`（`indexed`）：接收方地址</span><br><span class="line">  - `value`（未 `indexed`）：转账金额</span><br><span class="line"></span><br><span class="line">- `indexed` 修饰符允许事件数据被高效索引，最多 3 个参数可以使用 `indexed`。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">#### 2.2 **触发事件**</span><br><span class="line"></span><br><span class="line">```solidity</span><br><span class="line">solidity复制编辑function transfer(address _to, uint256 _amount) public &#123;</span><br><span class="line">    require(balance[msg.sender] &gt;= _amount, &quot;Insufficient balance&quot;);</span><br><span class="line">    balance[msg.sender] -= _amount;</span><br><span class="line">    balance[_to] += _amount;</span><br><span class="line"></span><br><span class="line">    // 触发 Transfer 事件</span><br><span class="line">    emit Transfer(msg.sender, _to, _amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>事件 <code>Transfer</code> 被 <code>emit</code> 关键字触发，并记录在交易日志中。</li>
<li>监听器（如前端）可以监听该事件，并更新 UI。</li>
</ul>
<h1 id="9-内置函数"><a href="#9-内置函数" class="headerlink" title="9.内置函数"></a>9.内置函数</h1><h2 id="1-数学运算相关"><a href="#1-数学运算相关" class="headerlink" title="1 数学运算相关"></a>1 数学运算相关</h2><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>addmod(uint x, uint y, uint m)</td>
<td>计算 <code>(x + y) % m</code>，避免溢出</td>
</tr>
<tr>
<td>mulmod(uint x, uint y, uint m)</td>
<td>计算 <code>(x * y) % m</code>，避免溢出</td>
</tr>
</tbody></table>
<h2 id="2-哈希计算"><a href="#2-哈希计算" class="headerlink" title="2.哈希计算"></a>2.哈希计算</h2><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>keccak256(bytes memory data)</td>
<td>计算 <code>Keccak-256</code> 哈希值</td>
</tr>
<tr>
<td>sha256(bytes memory data)</td>
<td>计算 <code>SHA-256</code> 哈希值</td>
</tr>
<tr>
<td>ripemd160(bytes memory data)</td>
<td>计算 <code>RIPEMD-160</code> 哈希值</td>
</tr>
</tbody></table>
<h2 id="3-地址相关"><a href="#3-地址相关" class="headerlink" title="3.地址相关"></a>3.地址相关</h2><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>address(uint160 value)</td>
<td>uint160<code>转换为</code>address</td>
</tr>
<tr>
<td>uint160(address value)</td>
<td>address<code>转换为</code>uint160</td>
</tr>
<tr>
<td>balance</td>
<td>获取账户余额</td>
</tr>
<tr>
<td>send(uint256 amount)</td>
<td>发送以太币（返回 <code>bool</code>）</td>
</tr>
<tr>
<td>transfer(uint256 amount)</td>
<td>发送以太币（失败时回滚）</td>
</tr>
<tr>
<td>call(bytes memory data)</td>
<td>低级调用外部合约</td>
</tr>
</tbody></table>
<h2 id="4-区块和交易信息"><a href="#4-区块和交易信息" class="headerlink" title="4. 区块和交易信息"></a>4. 区块和交易信息</h2><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>block.number</code></td>
<td>当前区块号</td>
</tr>
<tr>
<td><code>block.timestamp</code></td>
<td>当前区块的时间戳</td>
</tr>
<tr>
<td><code>block.coinbase</code></td>
<td>当前区块的矿工地址</td>
</tr>
<tr>
<td><code>block.difficulty</code></td>
<td>当前区块的难度</td>
</tr>
<tr>
<td><code>gasleft()</code></td>
<td>剩余的 gas 量</td>
</tr>
<tr>
<td><code>msg.sender</code></td>
<td>交易发送者地址</td>
</tr>
<tr>
<td><code>msg.value</code></td>
<td>交易发送的以太币数量</td>
</tr>
<tr>
<td><code>msg.data</code></td>
<td>调用数据</td>
</tr>
<tr>
<td><code>tx.origin</code></td>
<td>交易发起者的地址</td>
</tr>
</tbody></table>
<h2 id="5-ABI-编码和解码"><a href="#5-ABI-编码和解码" class="headerlink" title="5 ABI 编码和解码"></a>5 <strong>ABI 编码和解码</strong></h2><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>abi.encode(...)</code></td>
<td>编码参数为 <code>bytes</code></td>
</tr>
<tr>
<td><code>abi.encodePacked(...)</code></td>
<td>压缩编码（节省空间）</td>
</tr>
<tr>
<td><code>abi.decode(bytes memory data, (type1, type2, ...))</code></td>
<td>解码数据</td>
</tr>
<tr>
<td><code>abi.encodeWithSelector(bytes4 selector, ...)</code></td>
<td>编码带 <code>selector</code> 的调用数据</td>
</tr>
<tr>
<td><code>abi.encodeWithSignature(string memory signature, ...)</code></td>
<td>编码带函数签名的调用数据</td>
</tr>
</tbody></table>
<h2 id="6-合约创建"><a href="#6-合约创建" class="headerlink" title="6. 合约创建"></a>6. <strong>合约创建</strong></h2><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>new ContractName&#123;value: X, gas: Y&#125;(params)</code></td>
<td>部署新合约</td>
</tr>
<tr>
<td><code>selfdestruct(address payable recipient)</code></td>
<td>销毁合约，并转移剩余资金</td>
</tr>
</tbody></table>
<h1 id="10-以太坊的账户（转账方法"><a href="#10-以太坊的账户（转账方法" class="headerlink" title="10 以太坊的账户（转账方法"></a>10 以太坊的账户（转账方法</h1><p>其中以太坊账户分为两类：</p>
<ol>
<li><strong>外部账户（EOA，Externally Owned Account）</strong><ul>
<li>由私钥控制。</li>
<li>通过 <code>msg.sender</code> 发送交易。</li>
<li>不能存储代码，仅能发送和接收以太币。</li>
</ul>
</li>
<li><strong>合约账户（Contract Account）</strong><ul>
<li>由智能合约代码控制。</li>
<li>具有存储和代码逻辑。</li>
<li>由外部账户或合约调用执行。</li>
</ul>
</li>
</ol>
<h2 id="send-call-transfer-对比"><a href="#send-call-transfer-对比" class="headerlink" title="send call transfer 对比"></a>send call transfer 对比</h2><table>
<thead>
<tr>
<th>方法</th>
<th>失败时</th>
<th>Gas 限制</th>
<th>是否推荐</th>
</tr>
</thead>
<tbody><tr>
<td><code>send()</code></td>
<td>返回 <code>false</code></td>
<td>2300</td>
<td>不推荐（可能导致资金丢失）</td>
</tr>
<tr>
<td><code>transfer()</code></td>
<td>回滚交易</td>
<td>2300</td>
<td>推荐（安全性较高）</td>
</tr>
<tr>
<td><code>call()</code></td>
<td>返回 <code>(success, data)</code></td>
<td>无限制</td>
<td>推荐（但需注意重入攻击）</td>
</tr>
</tbody></table>
<h3 id="send"><a href="#send" class="headerlink" title="send()"></a><strong><code>send()</code></strong></h3><p><code>send()</code> 方法返回 <code>bool</code>，需要手动检查成功与否：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(bool success,) = payableAddr.send(1 ether);</span><br><span class="line">require(success, &quot;Send failed&quot;);</span><br></pre></td></tr></table></figure>

<p>⚠️ <strong>不推荐使用</strong>，因为它不会自动回滚交易。</p>
<h3 id="transfer"><a href="#transfer" class="headerlink" title="transfer()"></a><strong><code>transfer()</code></strong></h3><p><code>transfer()</code> 方法失败时会自动回滚：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payableAddr.transfer(1 ether);</span><br></pre></td></tr></table></figure>

<p>✅ <strong>推荐使用</strong>，因为它避免了资金丢失。</p>
<h3 id="call"><a href="#call" class="headerlink" title="call()"></a><strong><code>call()</code></strong></h3><p><code>call()</code> 是最低级的调用方式，可以传递数据，但容易引发重入攻击：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(bool success, bytes memory data) = payableAddr.call&#123;value: 1 ether&#125;(&quot;&quot;);</span><br><span class="line">require(success, &quot;Call failed&quot;);</span><br></pre></td></tr></table></figure>

<p>⚠️ <strong>推荐</strong> 用于复杂合约交互，但需加 <code>reentrancy</code> 保护。（防止重入）</p>
<h1 id="11-映射（mapping）"><a href="#11-映射（mapping）" class="headerlink" title="11. 映射（mapping）"></a>11. 映射（mapping）</h1><p><code>mapping</code> 是 Solidity 中的一种哈希表，键值对存储数据，但 <strong>无法遍历</strong> 或 <strong>获取长度</strong>。</p>
<h3 id="mapping-语法"><a href="#mapping-语法" class="headerlink" title="mapping 语法"></a><strong><code>mapping</code> 语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">solidity复制编辑mapping(address =&gt; uint256) public balances;</span><br><span class="line">mapping(uint256 =&gt; mapping(address =&gt; bool)) public approvals; // 多级映射</span><br></pre></td></tr></table></figure>

<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a><strong>基本操作</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">solidity复制编辑balances[msg.sender] = 100; // 赋值</span><br><span class="line">uint256 bal = balances[msg.sender]; // 读取</span><br><span class="line">bool isApproved = approvals[1][msg.sender]; // 读取多级映射</span><br><span class="line">delete balances[msg.sender]; // 删除（重置为默认值）</span><br></pre></td></tr></table></figure>

<h1 id="12-数组（Array"><a href="#12-数组（Array" class="headerlink" title="12.数组（Array)"></a>12.数组（Array)</h1><p>Solidity 数组有 <strong>固定长度</strong> 和 <strong>动态数组</strong> 两种。</p>
<h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a><strong>数组定义</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint256[] public dynamicArray; // 动态数组</span><br><span class="line">uint256[5] public fixedArray;  // 固定长度数组</span><br></pre></td></tr></table></figure>

<h3 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a><strong>增删查改</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dynamicArray.push(10); // 添加元素</span><br><span class="line">uint256 value = dynamicArray[0]; // 读取</span><br><span class="line">dynamicArray[0] = 20; // 修改</span><br><span class="line">delete dynamicArray[0]; // 删除（重置为默认值 0）</span><br><span class="line">dynamicArray.pop(); // 删除最后一个元素（仅限动态数组）</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：固定长度数组不能 <code>push()</code> 或 <code>pop()</code>。</p>
<h1 id="13-delete-关键字"><a href="#13-delete-关键字" class="headerlink" title="13.delete 关键字"></a>13.delete 关键字</h1><ul>
<li><code>delete</code> 关键字不会真正删除元素，而是 <strong>重置为默认值</strong>。</li>
<li>适用于数组、<code>mapping</code> 和结构体。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint256[] public arr = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">function resetArray() public &#123;</span><br><span class="line">    delete arr[1]; // 变为 0，数组长度不变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 <code>mapping</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">function clearBalance(address user) public &#123;</span><br><span class="line">    delete balances[user]; // 重置为 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="14-receive-和-fallback"><a href="#14-receive-和-fallback" class="headerlink" title="14.receive 和 fallback"></a>14.receive 和 fallback</h1><h2 id="接收ETH的receive函数"><a href="#接收ETH的receive函数" class="headerlink" title="接收ETH的receive函数"></a>接收ETH的receive函数</h2><p>其中receive函数实在接收ETH转账时被调用的函数。一个合约最多有一个receive（）函数，声明方式直接为receive() external payable { … }。不需要function关键字。receive（）函数不能有任何参数，不能有任何返回值，必须包含external和payable。</p>
<p>接受ETH时候， receive()<code>会被触发。</code>receive()<code>最好不要执行太多的逻辑因为如果别人用</code>send<code>和</code>transfer<code>方法发送</code>ETH<code>的话，</code>gas<code>会限制在</code>2300<code>，</code>receive()<code>太复杂可能会触发</code>Out of Gas<code>报错；如果用</code>call<code>就可以自定义</code>gas&#96;执行更复杂的逻辑（这三种发送ETH的方法我们之后会讲到）。</p>
<p>我们可以在<code>receive()</code>里发送一个<code>event</code>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 定义事件</span><br><span class="line">event Received(address Sender, uint Value);</span><br><span class="line">// 接收ETH时释放Received事件</span><br><span class="line">receive() external payable &#123;</span><br><span class="line">    emit Received(msg.sender, msg.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回退函数-fallback"><a href="#回退函数-fallback" class="headerlink" title="回退函数 fallback"></a>回退函数 fallback</h2><p><code>fallback()</code>函数会在调用合约不存在的函数时被触发。可用于接收ETH，也可以用于代理合约<code>proxy contract</code>。<code>fallback()</code>声明时不需要<code>function</code>关键字，必须由<code>external</code>修饰，一般也会用<code>payable</code>修饰，用于接收ETH:<code>fallback() external payable &#123; ... &#125;</code>。</p>
<p>我们定义一个<code>fallback()</code>函数，被触发时候会释放<code>fallbackCalled</code>事件，并输出<code>msg.sender</code>，<code>msg.value</code>和<code>msg.data</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">event fallbackCalled(address Sender, uint Value, bytes Data);</span><br><span class="line"></span><br><span class="line">// fallback</span><br><span class="line">fallback() external payable&#123;</span><br><span class="line">    emit fallbackCalled(msg.sender, msg.value, msg.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p>触发fallback() 还是 receive()?<br>           接收ETH<br>              |<br>         msg.data是空？<br>            &#x2F;  <br>          是    否<br>          &#x2F;      <br>receive()存在?   fallback()<br>        &#x2F; <br>       是  否<br>      &#x2F;     <br>receive()   fallback()</p>
<p>简单来说，合约接收<code>ETH</code>时，<code>msg.data</code>为空且存在<code>receive()</code>时，会触发<code>receive()</code>；<code>msg.data</code>不为空或不存在<code>receive()</code>时，会触发<code>fallback()</code>，此时<code>fallback()</code>必须为<code>payable</code>。</p>
<p><code>receive()</code>和<code>payable fallback()</code>均不存在的时候，向合约<strong>直接</strong>发送<code>ETH</code>将会报错（你仍可以通过带有<code>payable</code>的函数向合约发送<code>ETH</code>）</p>
<h1 id="15-构造函数和修饰器"><a href="#15-构造函数和修饰器" class="headerlink" title="15 构造函数和修饰器"></a>15 构造函数和修饰器</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数（<code>constructor</code>）是一种特殊的函数，每个合约可以定义一个，并在部署合约的时候自动运行一次。它可以用来初始化合约的一些参数，例如初始化合约的<code>owner</code>地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">address owner; // 定义owner变量</span><br><span class="line"></span><br><span class="line">// 构造函数</span><br><span class="line">constructor(address initialOwner) &#123;</span><br><span class="line">    owner = initialOwner; // 在部署合约的时候，将owner设置为传入的initialOwner地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：构造函数在不同的Solidity版本中的语法并不一致，在Solidity 0.4.22之前，构造函数不使用 <code>constructor</code> 而是使用与合约名同名的函数作为构造函数而使用，由于这种旧写法容易使开发者在书写时发生疏漏（例如合约名叫 <code>Parents</code>，构造函数名写成 <code>parents</code>），使得构造函数变成普通函数，引发漏洞，所以0.4.22版本及之后，采用了全新的 <code>constructor</code> 写法。</p>
<p>构造函数的旧写法代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity =0.4.21;</span><br><span class="line">contract Parents &#123;</span><br><span class="line">    // 与合约名Parents同名的函数就是构造函数</span><br><span class="line">    function Parents () public &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h2><p>修饰器（<code>modifier</code>）是<code>Solidity</code>特有的语法，类似于面向对象编程中的装饰器（<code>decorator</code>），声明函数拥有的特性，并减少代码冗余。它就像钢铁侠的智能盔甲，穿上它的函数会带有某些特定的行为。<code>modifier</code>的主要使用场景是运行函数前的检查，例如地址，变量，余额等。</p>
<p>我们来定义一个叫做onlyOwner的modifier：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 定义modifier</span><br><span class="line">modifier onlyOwner &#123;</span><br><span class="line">   require(msg.sender == owner); // 检查调用者是否为owner地址</span><br><span class="line">   _; // 如果是的话，继续运行函数主体；否则报错并revert交易</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>带有<code>onlyOwner</code>修饰符的函数只能被<code>owner</code>地址调用，比如下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function changeOwner(address _newOwner) external onlyOwner&#123;</span><br><span class="line">   owner = _newOwner; // 只有owner地址运行这个函数，并改变owner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了一个<code>changeOwner</code>函数，运行它可以改变合约的<code>owner</code>，但是由于<code>onlyOwner</code>修饰符的存在，只有原先的<code>owner</code>可以调用，别人调用就会报错。这也是最常用的控制智能合约权限的方法。</p>
<h1 id="16-函数重载"><a href="#16-函数重载" class="headerlink" title="16. 函数重载"></a>16. 函数重载</h1><p><strong>重载：</strong></p>
<p><code>Solidity</code>中允许函数进行重载（<code>overloading</code>），即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，<code>Solidity</code>不允许修饰器（<code>modifier</code>）重载。</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>举个例子，我们可以定义两个都叫<code>saySomething()</code>的函数，一个没有任何参数，输出<code>&quot;Nothing&quot;</code>；另一个接收一个<code>string</code>参数，输出这个<code>string</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function saySomething() public pure returns(string memory)&#123;</span><br><span class="line">    return(&quot;Nothing&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function saySomething(string memory something) public pure returns(string memory)&#123;</span><br><span class="line">    return(something);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终重载函数在经过编译器编译后，由于不同的参数类型，都变成了不同的函数选择器（selector）</p>
<h1 id="17-库合约"><a href="#17-库合约" class="headerlink" title="17. 库合约"></a>17. 库合约</h1><p>特点（库合约是一种特殊的合约，为了提升<code>Solidity</code>代码的复用性和减少<code>gas</code>而存在。库合约是一系列的函数合集，由大神或者项目方创作，咱们站在巨人的肩膀上，会用就行了。）</p>
<p>和普通合约的不同点：</p>
<ol>
<li><p>不能存在状态变量</p>
</li>
<li><p>不能够继承或被继承</p>
</li>
<li><p>不能接收以太币</p>
</li>
<li><p>不可以被销毁   </p>
<h2 id="Strings库合约"><a href="#Strings库合约" class="headerlink" title="Strings库合约"></a>Strings库合约<a target="_blank" rel="noopener" href="https://www.wtf.academy/docs/solidity-102/Library/#strings%E5%BA%93%E5%90%88%E7%BA%A6"></a></h2><p><code>Strings库合约</code>是将<code>uint256</code>类型转换为相应的<code>string</code>类型的代码库，样例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">library Strings &#123;</span><br><span class="line">    bytes16 private constant _HEX_SYMBOLS = &quot;0123456789abcdef&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` decimal representation.</span><br><span class="line">     */</span><br><span class="line">    function toString(uint256 value) public pure returns (string memory) &#123;</span><br><span class="line">        // Inspired by OraclizeAPI&#x27;s implementation - MIT licence</span><br><span class="line">        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol</span><br><span class="line"></span><br><span class="line">        if (value == 0) &#123;</span><br><span class="line">            return &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 temp = value;</span><br><span class="line">        uint256 digits;</span><br><span class="line">        while (temp != 0) &#123;</span><br><span class="line">            digits++;</span><br><span class="line">            temp /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes memory buffer = new bytes(digits);</span><br><span class="line">        while (value != 0) &#123;</span><br><span class="line">            digits -= 1;</span><br><span class="line">            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));</span><br><span class="line">            value /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return string(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.</span><br><span class="line">     */</span><br><span class="line">    function toHexString(uint256 value) public pure returns (string memory) &#123;</span><br><span class="line">        if (value == 0) &#123;</span><br><span class="line">            return &quot;0x00&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 temp = value;</span><br><span class="line">        uint256 length = 0;</span><br><span class="line">        while (temp != 0) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            temp &gt;&gt;= 8;</span><br><span class="line">        &#125;</span><br><span class="line">        return toHexString(value, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.</span><br><span class="line">     */</span><br><span class="line">    function toHexString(uint256 value, uint256 length) public pure returns (string memory) &#123;</span><br><span class="line">        bytes memory buffer = new bytes(2 * length + 2);</span><br><span class="line">        buffer[0] = &quot;0&quot;;</span><br><span class="line">        buffer[1] = &quot;x&quot;;</span><br><span class="line">        for (uint256 i = 2 * length + 1; i &gt; 1; --i) &#123;</span><br><span class="line">            buffer[i] = _HEX_SYMBOLS[value &amp; 0xf];</span><br><span class="line">            value &gt;&gt;= 4;</span><br><span class="line">        &#125;</span><br><span class="line">        require(value == 0, &quot;Strings: hex length insufficient&quot;);</span><br><span class="line">        return string(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他主要包含两个函数，<code>toString()</code>将<code>uint256</code>转为<code>string</code>，<code>toHexString()</code>将<code>uint256</code>转换为<code>16进制</code>，在转换为<code>string</code>。</p>
</li>
</ol>
<h2 id="如何使用库合约"><a href="#如何使用库合约" class="headerlink" title="如何使用库合约"></a>如何使用库合约</h2><p>我们用<code>Strings</code>库合约的<code>toHexString()</code>来演示两种使用库合约中函数的办法。</p>
<ol>
<li><p>利用using for指令</p>
<p>指令<code>using A for B;</code>可用于附加库合约（从库 A）到任何类型（B）。添加完指令后，库<code>A</code>中的函数会自动添加为<code>B</code>类型变量的成员，可以直接调用。注意：在调用的时候，这个变量会被当作第一个参数传递给函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 利用using for指令</span><br><span class="line">using Strings for uint256;</span><br><span class="line">function getString1(uint256 _number) public pure returns(string memory)&#123;</span><br><span class="line">    // 库合约中的函数会自动添加为uint256型变量的成员</span><br><span class="line">    return _number.toHexString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过库合约名称调用函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 直接通过库合约名调用</span><br><span class="line">function getString2(uint256 _number) public pure returns(string memory)&#123;</span><br><span class="line">    return Strings.toHexString(_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>会用大神写的就可以了。我们只需要知道什么情况该用什么库合约。常用的有：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Strings.sol">Strings</a>：将<code>uint256</code>转换为<code>String</code></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Address.sol">Address</a>：判断某个地址是否为合约地址</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Create2.sol">Create2</a>：更安全的使用<code>Create2 EVM opcode</code></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Arrays.sol">Arrays</a>：跟数组相关的库合约</p>
<p>​</p>
</li>
</ol>
</li>
</ol>
<h1 id="18-import"><a href="#18-import" class="headerlink" title="18.import"></a>18.import</h1><h2 id="import用法"><a href="#import用法" class="headerlink" title="import用法"></a><code>import</code>用法</h2><ul>
<li><p>通过源文件相对位置导入，例子：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文件结构</span><br><span class="line">├── Import.sol</span><br><span class="line">└── Yeye.sol</span><br><span class="line"></span><br><span class="line">// 通过文件相对位置import</span><br><span class="line">import &#x27;./Yeye.sol&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过源文件网址导入网上的合约的全局符号，例子：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过网址引用</span><br><span class="line">import &#x27;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>npm</code>的目录导入，例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;@openzeppelin/contracts/access/Ownable.sol&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过指定<code>全局符号</code>导入合约特定的全局符号，例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Yeye&#125; from &#x27;./Yeye.sol&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用(<code>import</code>)在代码中的位置为：在声明版本号之后，在其余代码之前。</p>
</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">三叶</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/20/solidity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/">http://example.com/2025/03/20/solidity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">三叶的故事</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Solidity/">Solidity</a><a class="post-meta__tags" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></div><div class="post-share"><div class="social-share" data-image="/img/san-ye.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/03/14/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/san-ye.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">三叶</div><div class="author-info-description">三叶的世界</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">智能合约的概念</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">1.变量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">详细介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1布尔型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B4%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">2 整型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9C%B0%E5%9D%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">3.地址类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%97%E9%95%BF%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.</span> <span class="toc-text">4.字长字节数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">2.函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">四种函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">1.1.</span> <span class="toc-text">详细介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%AC%E5%85%B1%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.公共函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.内部函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.外部函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%A7%81%E6%9C%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.私有函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number"></span> <span class="toc-text">3.控制流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#if%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.</span> <span class="toc-text">if语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E8%AF%AD%E6%B3%95%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">1语法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-if-else-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.2.</span> <span class="toc-text">2.if-else 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-if-else-if-else-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.</span> <span class="toc-text">3. if-else if-else 语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF-%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.</span> <span class="toc-text">for循环(以及其他循环)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AF%AD%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">1.语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-while%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.</span> <span class="toc-text">2.while循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-do-while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.1.</span> <span class="toc-text">3.do-while 循环</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E7%BB%A7%E6%89%BF"><span class="toc-number"></span> <span class="toc-text">4继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%BB%A7%E6%89%BF"><span class="toc-number">1.</span> <span class="toc-text">简单继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">2.</span> <span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E5%99%A8%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">修饰器的继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">4.</span> <span class="toc-text">构造函数的继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E7%88%B6%E5%90%88%E7%BA%A6%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">调用父合约的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%92%BB%E7%9F%B3%E7%BB%A7%E6%89%BF"><span class="toc-number">6.</span> <span class="toc-text">钻石继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%8A%BD%E8%B1%A1%E5%90%88%E7%BA%A6"><span class="toc-number"></span> <span class="toc-text">5.抽象合约</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%90%88%E7%BA%A6"><span class="toc-number">1.</span> <span class="toc-text">抽象合约</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%8E%A5%E5%8F%A3"><span class="toc-number"></span> <span class="toc-text">6.接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">什么时候使用接口？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">区别和使用场景：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E4%BA%8B%E4%BB%B6"><span class="toc-number"></span> <span class="toc-text">7 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%A2%98-topics"><span class="toc-number">0.1.</span> <span class="toc-text">主题 topics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE-data"><span class="toc-number">0.2.</span> <span class="toc-text">数据 data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E4%BA%8B%E4%BB%B6"><span class="toc-number">0.3.</span> <span class="toc-text">释放事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E6%97%A5%E5%BF%97"><span class="toc-number"></span> <span class="toc-text">8.日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">1特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%97%A5%E5%BF%97%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">2.日志的声明与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97"><span class="toc-number">2.0.1.</span> <span class="toc-text">2.1 定义日志</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">9.内置函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3"><span class="toc-number">1.</span> <span class="toc-text">1 数学运算相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%93%88%E5%B8%8C%E8%AE%A1%E7%AE%97"><span class="toc-number">2.</span> <span class="toc-text">2.哈希计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3"><span class="toc-number">3.</span> <span class="toc-text">3.地址相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8C%BA%E5%9D%97%E5%92%8C%E4%BA%A4%E6%98%93%E4%BF%A1%E6%81%AF"><span class="toc-number">4.</span> <span class="toc-text">4. 区块和交易信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-ABI-%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">5 ABI 编码和解码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%90%88%E7%BA%A6%E5%88%9B%E5%BB%BA"><span class="toc-number">6.</span> <span class="toc-text">6. 合约创建</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E8%B4%A6%E6%88%B7%EF%BC%88%E8%BD%AC%E8%B4%A6%E6%96%B9%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">10 以太坊的账户（转账方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#send-call-transfer-%E5%AF%B9%E6%AF%94"><span class="toc-number">1.</span> <span class="toc-text">send call transfer 对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#send"><span class="toc-number">1.1.</span> <span class="toc-text">send()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transfer"><span class="toc-number">1.2.</span> <span class="toc-text">transfer()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call"><span class="toc-number">1.3.</span> <span class="toc-text">call()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E6%98%A0%E5%B0%84%EF%BC%88mapping%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">11. 映射（mapping）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mapping-%E8%AF%AD%E6%B3%95"><span class="toc-number">0.1.</span> <span class="toc-text">mapping 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">0.2.</span> <span class="toc-text">基本操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E6%95%B0%E7%BB%84%EF%BC%88Array"><span class="toc-number"></span> <span class="toc-text">12.数组（Array)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89"><span class="toc-number">0.1.</span> <span class="toc-text">数组定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9"><span class="toc-number">0.2.</span> <span class="toc-text">增删查改</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-delete-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number"></span> <span class="toc-text">13.delete 关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-receive-%E5%92%8C-fallback"><span class="toc-number"></span> <span class="toc-text">14.receive 和 fallback</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6ETH%E7%9A%84receive%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">接收ETH的receive函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E9%80%80%E5%87%BD%E6%95%B0-fallback"><span class="toc-number">2.</span> <span class="toc-text">回退函数 fallback</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">两者区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E4%BF%AE%E9%A5%B0%E5%99%A8"><span class="toc-number"></span> <span class="toc-text">15 构造函数和修饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">修饰器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number"></span> <span class="toc-text">16. 函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">0.1.</span> <span class="toc-text">函数重载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-%E5%BA%93%E5%90%88%E7%BA%A6"><span class="toc-number"></span> <span class="toc-text">17. 库合约</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Strings%E5%BA%93%E5%90%88%E7%BA%A6"><span class="toc-number">1.</span> <span class="toc-text">Strings库合约</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%BA%93%E5%90%88%E7%BA%A6"><span class="toc-number">2.</span> <span class="toc-text">如何使用库合约</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-import"><span class="toc-number"></span> <span class="toc-text">18.import</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#import%E7%94%A8%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">import用法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text"></span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/20/solidity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="Solidity 学习笔记">Solidity 学习笔记</a><time datetime="2025-03-19T23:00:00.000Z" title="发表于 2025-03-20 07:00:00">2025-03-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/14/hello-world/" title="Hello World">Hello World</a><time datetime="2025-03-14T11:41:09.156Z" title="发表于 2025-03-14 19:41:09">2025-03-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By 三叶</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>